-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Swagger 2.0 data model
--   
--   Please see README.md
@package swagger2
@version 1.2.1

module Data.Swagger.SchemaOptions

-- | Options that specify how to encode your type to Swagger schema.
data SchemaOptions
SchemaOptions :: (String -> String) -> (String -> String) -> (String -> String) -> Bool -> Bool -> SchemaOptions

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: SchemaOptions -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: SchemaOptions -> String -> String

-- | Function applied to datatype name.
[datatypeNameModifier] :: SchemaOptions -> String -> String

-- | If <tt><a>True</a></tt> the constructors of a datatype, with all
--   nullary constructors, will be encoded to a string enumeration schema
--   with the constructor tags as possible values.
[allNullaryToStringTag] :: SchemaOptions -> Bool

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: SchemaOptions -> Bool

-- | Default encoding <tt><a>SchemaOptions</a></tt>.
--   
--   <pre>
--   <a>SchemaOptions</a>
--   { <a>fieldLabelModifier</a>     = id
--   , <a>constructorTagModifier</a> = id
--   , <a>datatypeNameModifier</a>   = id
--   , <a>allNullaryToStringTag</a>  = True
--   , <a>unwrapUnaryRecords</a>     = False
--   }
--   </pre>
defaultSchemaOptions :: SchemaOptions

module Data.Swagger.Internal.Utils
swaggerFieldRules :: LensRules
gunfoldEnum :: String -> [a] -> (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
hashMapMapKeys :: (Eq k', Hashable k') => (k -> k') -> HashMap k v -> HashMap k' v
hashMapTraverseKeys :: (Eq k', Hashable k', Applicative f) => (k -> f k') -> HashMap k v -> f (HashMap k' v)
hashMapReadKeys :: (Eq k, Read k, Hashable k, Alternative f) => HashMap String v -> f (HashMap k v)
jsonPrefix :: String -> Options
parseOneOf :: ToJSON a => [a] -> Value -> Parser a
omitEmptiesExcept :: (Text -> Value -> Bool) -> Value -> Value
omitEmpties :: Value -> Value
genericToJSONWithSub :: (Generic a, GToJSON (Rep a)) => Text -> Options -> a -> Value
genericParseJSONWithSub :: (Generic a, GFromJSON (Rep a)) => Text -> Options -> Value -> Parser a
(<+>) :: Value -> Value -> Value
withDefaults :: (Value -> Parser a) -> [Pair] -> Value -> Parser a
genericMempty :: (Generic a, GMonoid (Rep a)) => a
genericMappend :: (Generic a, GMonoid (Rep a)) => a -> a -> a
class GMonoid f
gmempty :: GMonoid f => f p
gmappend :: GMonoid f => f p -> f p -> f p
class SwaggerMonoid m where swaggerMempty = mempty swaggerMappend = mappend
swaggerMempty :: SwaggerMonoid m => m
swaggerMappend :: SwaggerMonoid m => m -> m -> m
instance Data.Swagger.Internal.Utils.GMonoid GHC.Generics.U1
instance (Data.Swagger.Internal.Utils.GMonoid f, Data.Swagger.Internal.Utils.GMonoid g) => Data.Swagger.Internal.Utils.GMonoid (f GHC.Generics.:*: g)
instance Data.Swagger.Internal.Utils.SwaggerMonoid a => Data.Swagger.Internal.Utils.GMonoid (GHC.Generics.K1 i a)
instance Data.Swagger.Internal.Utils.GMonoid f => Data.Swagger.Internal.Utils.GMonoid (GHC.Generics.M1 i t f)
instance Data.Swagger.Internal.Utils.SwaggerMonoid [a]
instance GHC.Classes.Ord k => Data.Swagger.Internal.Utils.SwaggerMonoid (Data.Map.Base.Map k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Swagger.Internal.Utils.SwaggerMonoid (Data.HashMap.Base.HashMap k v)
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Text.Internal.Text
instance Data.Swagger.Internal.Utils.SwaggerMonoid (GHC.Base.Maybe a)

module Data.Swagger.Declare

-- | A declare monad transformer parametrized by:
--   
--   <ul>
--   <li><tt>d</tt> — the output to accumulate (declarations);</li>
--   <li><tt>m</tt> — the inner monad.</li>
--   </ul>
--   
--   This monad transformer is similar to both state and writer monad
--   transformers. Thus it can be seen as
--   
--   <ul>
--   <li>a restricted append-only version of a state monad transformer
--   or</li>
--   <li>a writer monad transformer with the extra ability to read all
--   previous output.</li>
--   </ul>
newtype DeclareT d m a
DeclareT :: (d -> m (d, a)) -> DeclareT d m a
[runDeclareT] :: DeclareT d m a -> d -> m (d, a)

-- | Definitions of <tt>declare</tt> and <tt>look</tt> must satisfy the
--   following laws:
--   
--   <ul>
--   <li><i><i>monoid homomorphism (mempty)</i></i> <tt><a>declare</a>
--   mempty == return ()</tt></li>
--   <li><i><i>monoid homomorphism (mappend)</i></i> <tt><a>declare</a> x
--   &gt;&gt; <a>declare</a> y == <a>declare</a> (x &lt;&gt; y)</tt> for
--   every <tt>x</tt>, <tt>y</tt></li>
--   <li><i><i><tt>declare</tt>-<tt>look</tt></i></i> <tt><a>declare</a> x
--   &gt;&gt; <a>look</a> == <a>fmap</a> (&lt;&gt; x) <a>look</a> &lt;*
--   <a>declare</a> x</tt> for every <tt>x</tt></li>
--   <li><i><i><tt>look</tt> as left identity</i></i> <tt><a>look</a>
--   &gt;&gt; m == m</tt> for every <tt>m</tt></li>
--   </ul>
class (Applicative m, Monad m) => MonadDeclare d m | m -> d

-- | <tt><a>declare</a> x</tt> is an action that produces the output
--   <tt>x</tt>.
declare :: MonadDeclare d m => d -> m ()

-- | <tt><a>look</a></tt> is an action that returns all the output so far.
look :: MonadDeclare d m => m d

-- | Retrieve a function of all the output so far.
looks :: MonadDeclare d m => (d -> a) -> m a

-- | Evaluate <tt><a>DeclareT</a> d m a</tt> computation, ignoring new
--   output <tt>d</tt>.
evalDeclareT :: Monad m => DeclareT d m a -> d -> m a

-- | Execute <tt><tt>DeclateT</tt> d m a</tt> computation, ignoring result
--   and only producing new output <tt>d</tt>.
execDeclareT :: Monad m => DeclareT d m a -> d -> m d

-- | Evaluate <tt><a>DeclareT</a> d m a</tt> computation, starting with
--   empty output history.
undeclareT :: (Monad m, Monoid d) => DeclareT d m a -> m a

-- | A declare monad parametrized by <tt>d</tt> — the output to accumulate
--   (declarations).
--   
--   This monad is similar to both state and writer monads. Thus it can be
--   seen as
--   
--   <ul>
--   <li>a restricted append-only version of a state monad or</li>
--   <li>a writer monad with the extra ability to read all previous
--   output.</li>
--   </ul>
type Declare d = DeclareT d Identity

-- | Run <tt><a>Declare</a> d a</tt> computation with output history
--   <tt>d</tt>, producing result <tt>a</tt> and new output <tt>d</tt>.
runDeclare :: Declare d a -> d -> (d, a)

-- | Evaluate <tt><a>Declare</a> d a</tt> computation, ignoring output
--   <tt>d</tt>.
evalDeclare :: Declare d a -> d -> a

-- | Execute <tt><tt>Declate</tt> d a</tt> computation, ignoring result and
--   only producing output <tt>d</tt>.
execDeclare :: Declare d a -> d -> d

-- | Evaluate <tt><a>DeclareT</a> d m a</tt> computation, starting with
--   empty output history.
undeclare :: Monoid d => Declare d a -> a
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Swagger.Declare.DeclareT d m)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, GHC.Base.Monoid d) => GHC.Base.Applicative (Data.Swagger.Declare.DeclareT d m)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, GHC.Base.Monoid d) => GHC.Base.Monad (Data.Swagger.Declare.DeclareT d m)
instance GHC.Base.Monoid d => Control.Monad.Trans.Class.MonadTrans (Data.Swagger.Declare.DeclareT d)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, GHC.Base.Monoid d) => Data.Swagger.Declare.MonadDeclare d (Data.Swagger.Declare.DeclareT d m)

module Data.Swagger.Internal

-- | A list of definitions that can be used in references.
type Definitions = HashMap Text

-- | This is the root document object for the API specification.
data Swagger
Swagger :: Info -> Maybe Host -> Maybe FilePath -> Maybe [Scheme] -> MimeList -> MimeList -> HashMap FilePath PathItem -> Definitions Schema -> Definitions Param -> Definitions Response -> Definitions SecurityScheme -> [SecurityRequirement] -> [Tag] -> Maybe ExternalDocs -> Swagger

-- | Provides metadata about the API. The metadata can be used by the
--   clients if needed.
[_swaggerInfo] :: Swagger -> Info

-- | The host (name or ip) serving the API. It MAY include a port. If the
--   host is not included, the host serving the documentation is to be used
--   (including the port).
[_swaggerHost] :: Swagger -> Maybe Host

-- | The base path on which the API is served, which is relative to the
--   host. If it is not included, the API is served directly under the
--   host. The value MUST start with a leading slash (/).
[_swaggerBasePath] :: Swagger -> Maybe FilePath

-- | The transfer protocol of the API. If the schemes is not included, the
--   default scheme to be used is the one used to access the Swagger
--   definition itself.
[_swaggerSchemes] :: Swagger -> Maybe [Scheme]

-- | A list of MIME types the APIs can consume. This is global to all APIs
--   but can be overridden on specific API calls.
[_swaggerConsumes] :: Swagger -> MimeList

-- | A list of MIME types the APIs can produce. This is global to all APIs
--   but can be overridden on specific API calls.
[_swaggerProduces] :: Swagger -> MimeList

-- | The available paths and operations for the API. Holds the relative
--   paths to the individual endpoints. The path is appended to the
--   <tt><tt>basePath</tt></tt> in order to construct the full URL.
[_swaggerPaths] :: Swagger -> HashMap FilePath PathItem

-- | An object to hold data types produced and consumed by operations.
[_swaggerDefinitions] :: Swagger -> Definitions Schema

-- | An object to hold parameters that can be used across operations. This
--   property does not define global parameters for all operations.
[_swaggerParameters] :: Swagger -> Definitions Param

-- | An object to hold responses that can be used across operations. This
--   property does not define global responses for all operations.
[_swaggerResponses] :: Swagger -> Definitions Response

-- | Security scheme definitions that can be used across the specification.
[_swaggerSecurityDefinitions] :: Swagger -> Definitions SecurityScheme

-- | A declaration of which security schemes are applied for the API as a
--   whole. The list of values describes alternative security schemes that
--   can be used (that is, there is a logical OR between the security
--   requirements). Individual operations can override this definition.
[_swaggerSecurity] :: Swagger -> [SecurityRequirement]

-- | A list of tags used by the specification with additional metadata. The
--   order of the tags can be used to reflect on their order by the parsing
--   tools. Not all tags that are used by the Operation Object must be
--   declared. The tags that are not declared may be organized randomly or
--   based on the tools' logic. Each tag name in the list MUST be unique.
[_swaggerTags] :: Swagger -> [Tag]

-- | Additional external documentation.
[_swaggerExternalDocs] :: Swagger -> Maybe ExternalDocs

-- | The object provides metadata about the API. The metadata can be used
--   by the clients if needed, and can be presented in the Swagger-UI for
--   convenience.
data Info
Info :: Text -> Maybe Text -> Maybe Text -> Maybe Contact -> Maybe License -> Text -> Info

-- | The title of the application.
[_infoTitle] :: Info -> Text

-- | A short description of the application. GFM syntax can be used for
--   rich text representation.
[_infoDescription] :: Info -> Maybe Text

-- | The Terms of Service for the API.
[_infoTermsOfService] :: Info -> Maybe Text

-- | The contact information for the exposed API.
[_infoContact] :: Info -> Maybe Contact

-- | The license information for the exposed API.
[_infoLicense] :: Info -> Maybe License

-- | Provides the version of the application API (not to be confused with
--   the specification version).
[_infoVersion] :: Info -> Text

-- | Contact information for the exposed API.
data Contact
Contact :: Maybe Text -> Maybe URL -> Maybe Text -> Contact

-- | The identifying name of the contact person/organization.
[_contactName] :: Contact -> Maybe Text

-- | The URL pointing to the contact information.
[_contactUrl] :: Contact -> Maybe URL

-- | The email address of the contact person/organization.
[_contactEmail] :: Contact -> Maybe Text

-- | License information for the exposed API.
data License
License :: Text -> Maybe URL -> License

-- | The license name used for the API.
[_licenseName] :: License -> Text

-- | A URL to the license used for the API.
[_licenseUrl] :: License -> Maybe URL

-- | The host (name or ip) serving the API. It MAY include a port.
data Host
Host :: HostName -> Maybe PortNumber -> Host

-- | Host name.
[_hostName] :: Host -> HostName

-- | Optional port.
[_hostPort] :: Host -> Maybe PortNumber
hostConstr :: Constr
hostDataType :: DataType

-- | The transfer protocol of the API.
data Scheme
Http :: Scheme
Https :: Scheme
Ws :: Scheme
Wss :: Scheme

-- | Describes the operations available on a single path. A
--   <tt><a>PathItem</a></tt> may be empty, due to ACL constraints. The
--   path itself is still exposed to the documentation viewer but they will
--   not know which operations and parameters are available.
data PathItem
PathItem :: Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> [Referenced Param] -> PathItem

-- | A definition of a GET operation on this path.
[_pathItemGet] :: PathItem -> Maybe Operation

-- | A definition of a PUT operation on this path.
[_pathItemPut] :: PathItem -> Maybe Operation

-- | A definition of a POST operation on this path.
[_pathItemPost] :: PathItem -> Maybe Operation

-- | A definition of a DELETE operation on this path.
[_pathItemDelete] :: PathItem -> Maybe Operation

-- | A definition of a OPTIONS operation on this path.
[_pathItemOptions] :: PathItem -> Maybe Operation

-- | A definition of a HEAD operation on this path.
[_pathItemHead] :: PathItem -> Maybe Operation

-- | A definition of a PATCH operation on this path.
[_pathItemPatch] :: PathItem -> Maybe Operation

-- | A list of parameters that are applicable for all the operations
--   described under this path. These parameters can be overridden at the
--   operation level, but cannot be removed there. The list MUST NOT
--   include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_pathItemParameters] :: PathItem -> [Referenced Param]

-- | Describes a single API operation on a path.
data Operation
Operation :: [TagName] -> Maybe Text -> Maybe Text -> Maybe ExternalDocs -> Maybe Text -> Maybe MimeList -> Maybe MimeList -> [Referenced Param] -> Responses -> Maybe [Scheme] -> Maybe Bool -> [SecurityRequirement] -> Operation

-- | A list of tags for API documentation control. Tags can be used for
--   logical grouping of operations by resources or any other qualifier.
[_operationTags] :: Operation -> [TagName]

-- | A short summary of what the operation does. For maximum readability in
--   the swagger-ui, this field SHOULD be less than 120 characters.
[_operationSummary] :: Operation -> Maybe Text

-- | A verbose explanation of the operation behavior. GFM syntax can be
--   used for rich text representation.
[_operationDescription] :: Operation -> Maybe Text

-- | Additional external documentation for this operation.
[_operationExternalDocs] :: Operation -> Maybe ExternalDocs

-- | Unique string used to identify the operation. The id MUST be unique
--   among all operations described in the API. Tools and libraries MAY use
--   the it to uniquely identify an operation, therefore, it is recommended
--   to follow common programming naming conventions.
[_operationOperationId] :: Operation -> Maybe Text

-- | A list of MIME types the operation can consume. This overrides the
--   <tt><tt>consumes</tt></tt>. <tt>Just []</tt> MAY be used to clear the
--   global definition.
[_operationConsumes] :: Operation -> Maybe MimeList

-- | A list of MIME types the operation can produce. This overrides the
--   <tt><tt>produces</tt></tt>. <tt>Just []</tt> MAY be used to clear the
--   global definition.
[_operationProduces] :: Operation -> Maybe MimeList

-- | A list of parameters that are applicable for this operation. If a
--   parameter is already defined at the <tt><a>PathItem</a></tt>, the new
--   definition will override it, but can never remove it. The list MUST
--   NOT include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_operationParameters] :: Operation -> [Referenced Param]

-- | The list of possible responses as they are returned from executing
--   this operation.
[_operationResponses] :: Operation -> Responses

-- | The transfer protocol for the operation. The value overrides
--   <tt><tt>schemes</tt></tt>.
[_operationSchemes] :: Operation -> Maybe [Scheme]

-- | Declares this operation to be deprecated. Usage of the declared
--   operation should be refrained. Default value is <tt>False</tt>.
[_operationDeprecated] :: Operation -> Maybe Bool

-- | A declaration of which security schemes are applied for this
--   operation. The list of values describes alternative security schemes
--   that can be used (that is, there is a logical OR between the security
--   requirements). This definition overrides any declared top-level
--   security. To remove a top-level security declaration, <tt>Just []</tt>
--   can be used.
[_operationSecurity] :: Operation -> [SecurityRequirement]
newtype MimeList
MimeList :: [MediaType] -> MimeList
[getMimeList] :: MimeList -> [MediaType]
mimeListConstr :: Constr
mimeListDataType :: DataType

-- | Describes a single operation parameter. A unique parameter is defined
--   by a combination of a name and location.
data Param
Param :: Text -> Maybe Text -> Maybe Bool -> ParamAnySchema -> Param

-- | The name of the parameter. Parameter names are case sensitive.
[_paramName] :: Param -> Text

-- | A brief description of the parameter. This could contain examples of
--   use. GFM syntax can be used for rich text representation.
[_paramDescription] :: Param -> Maybe Text

-- | Determines whether this parameter is mandatory. If the parameter is in
--   "path", this property is required and its value MUST be true.
--   Otherwise, the property MAY be included and its default value is
--   <tt>False</tt>.
[_paramRequired] :: Param -> Maybe Bool

-- | Parameter schema.
[_paramSchema] :: Param -> ParamAnySchema
data ParamAnySchema
ParamBody :: (Referenced Schema) -> ParamAnySchema
ParamOther :: ParamOtherSchema -> ParamAnySchema
data ParamOtherSchema
ParamOtherSchema :: ParamLocation -> Maybe Bool -> ParamSchema ParamOtherSchema -> ParamOtherSchema

-- | The location of the parameter.
[_paramOtherSchemaIn] :: ParamOtherSchema -> ParamLocation

-- | Sets the ability to pass empty-valued parameters. This is valid only
--   for either <tt><a>ParamQuery</a></tt> or <tt><a>ParamFormData</a></tt>
--   and allows you to send a parameter with a name only or an empty value.
--   Default value is <tt>False</tt>.
[_paramOtherSchemaAllowEmptyValue] :: ParamOtherSchema -> Maybe Bool
[_paramOtherSchemaParamSchema] :: ParamOtherSchema -> ParamSchema ParamOtherSchema

-- | Items for <tt><a>SwaggerArray</a></tt> schemas.
--   
--   <tt><a>SwaggerItemsPrimitive</a></tt> should be used only for query
--   params, headers and path pieces. The <tt><a>CollectionFormat</a>
--   t</tt> parameter specifies how elements of an array should be
--   displayed. Note that <tt>fmt</tt> in <tt><a>SwaggerItemsPrimitive</a>
--   fmt schema</tt> specifies format for elements of type <tt>schema</tt>.
--   This is different from the original Swagger's <a>Items Object</a>.
--   
--   <tt><a>SwaggerItemsObject</a></tt> should be used to specify
--   homogenous array <tt><a>Schema</a></tt>s.
--   
--   <tt><a>SwaggerItemsArray</a></tt> should be used to specify tuple
--   <tt><a>Schema</a></tt>s.
data SwaggerItems t
SwaggerItemsPrimitive :: Maybe (CollectionFormat t) -> ParamSchema t -> SwaggerItems t
SwaggerItemsObject :: Referenced Schema -> SwaggerItems Schema
SwaggerItemsArray :: [Referenced Schema] -> SwaggerItems Schema
swaggerItemsPrimitiveConstr :: Constr
swaggerItemsDataType :: DataType
data SwaggerType t
SwaggerString :: SwaggerType t
SwaggerNumber :: SwaggerType t
SwaggerInteger :: SwaggerType t
SwaggerBoolean :: SwaggerType t
SwaggerArray :: SwaggerType t
SwaggerFile :: SwaggerType ParamOtherSchema
SwaggerNull :: SwaggerType Schema
SwaggerObject :: SwaggerType Schema
swaggerTypeConstr :: Data (SwaggerType t) => SwaggerType t -> Constr
swaggerTypeDataType :: Data (SwaggerType t) => SwaggerType t -> DataType
swaggerCommonTypes :: [SwaggerType t]
swaggerParamTypes :: [SwaggerType ParamOtherSchema]
swaggerSchemaTypes :: [SwaggerType Schema]
swaggerTypeConstrs :: [Constr]
data ParamLocation

-- | Parameters that are appended to the URL. For example, in
--   <tt>/items?id=###</tt>, the query parameter is <tt>id</tt>.
ParamQuery :: ParamLocation

-- | Custom headers that are expected as part of the request.
ParamHeader :: ParamLocation

-- | Used together with Path Templating, where the parameter value is
--   actually part of the operation's URL. This does not include the host
--   or base path of the API. For example, in
--   <tt><i>items</i>{itemId}</tt>, the path parameter is <tt>itemId</tt>.
ParamPath :: ParamLocation

-- | Used to describe the payload of an HTTP request when either
--   <tt>application/x-www-form-urlencoded</tt> or
--   <tt>multipart/form-data</tt> are used as the content type of the
--   request (in Swagger's definition, the <tt>consumes</tt> property of an
--   operation). This is the only parameter type that can be used to send
--   files, thus supporting the <tt><tt>ParamFile</tt></tt> type. Since
--   form parameters are sent in the payload, they cannot be declared
--   together with a body parameter for the same operation. Form parameters
--   have a different format based on the content-type used (for further
--   details, consult
--   <a>http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4</a>).
ParamFormData :: ParamLocation
type Format = Text

-- | Determines the format of the array.
data CollectionFormat t
CollectionCSV :: CollectionFormat t
CollectionSSV :: CollectionFormat t
CollectionTSV :: CollectionFormat t
CollectionPipes :: CollectionFormat t
CollectionMulti :: CollectionFormat ParamOtherSchema
collectionFormatConstr :: CollectionFormat t -> Constr
collectionFormatDataType :: DataType
collectionCommonFormats :: [CollectionFormat t]
type ParamName = Text
data Schema
Schema :: Maybe Text -> Maybe Text -> [ParamName] -> Maybe [Schema] -> HashMap Text (Referenced Schema) -> Maybe Schema -> Maybe Text -> Maybe Bool -> Maybe Xml -> Maybe ExternalDocs -> Maybe Value -> Maybe Integer -> Maybe Integer -> ParamSchema Schema -> Schema
[_schemaTitle] :: Schema -> Maybe Text
[_schemaDescription] :: Schema -> Maybe Text
[_schemaRequired] :: Schema -> [ParamName]
[_schemaAllOf] :: Schema -> Maybe [Schema]
[_schemaProperties] :: Schema -> HashMap Text (Referenced Schema)
[_schemaAdditionalProperties] :: Schema -> Maybe Schema
[_schemaDiscriminator] :: Schema -> Maybe Text
[_schemaReadOnly] :: Schema -> Maybe Bool
[_schemaXml] :: Schema -> Maybe Xml
[_schemaExternalDocs] :: Schema -> Maybe ExternalDocs
[_schemaExample] :: Schema -> Maybe Value
[_schemaMaxProperties] :: Schema -> Maybe Integer
[_schemaMinProperties] :: Schema -> Maybe Integer
[_schemaParamSchema] :: Schema -> ParamSchema Schema

-- | A <tt><a>Schema</a></tt> with an optional name. This name can be used
--   in references.
data NamedSchema
NamedSchema :: Maybe Text -> Schema -> NamedSchema
[_namedSchemaName] :: NamedSchema -> Maybe Text
[_namedSchemaSchema] :: NamedSchema -> Schema

-- | Regex pattern for <tt>string</tt> type.
type Pattern = Text
data ParamSchema t
ParamSchema :: Maybe Value -> SwaggerType t -> Maybe Format -> Maybe (SwaggerItems t) -> Maybe Scientific -> Maybe Bool -> Maybe Scientific -> Maybe Bool -> Maybe Integer -> Maybe Integer -> Maybe Pattern -> Maybe Integer -> Maybe Integer -> Maybe Bool -> Maybe [Value] -> Maybe Scientific -> ParamSchema t

-- | Declares the value of the parameter that the server will use if none
--   is provided, for example a <tt>"count"</tt> to control the number of
--   results per page might default to <tt>100</tt> if not supplied by the
--   client in the request. (Note: "default" has no meaning for required
--   parameters.) Unlike JSON Schema this value MUST conform to the defined
--   type for this parameter.
[_paramSchemaDefault] :: ParamSchema t -> Maybe Value
[_paramSchemaType] :: ParamSchema t -> SwaggerType t
[_paramSchemaFormat] :: ParamSchema t -> Maybe Format
[_paramSchemaItems] :: ParamSchema t -> Maybe (SwaggerItems t)
[_paramSchemaMaximum] :: ParamSchema t -> Maybe Scientific
[_paramSchemaExclusiveMaximum] :: ParamSchema t -> Maybe Bool
[_paramSchemaMinimum] :: ParamSchema t -> Maybe Scientific
[_paramSchemaExclusiveMinimum] :: ParamSchema t -> Maybe Bool
[_paramSchemaMaxLength] :: ParamSchema t -> Maybe Integer
[_paramSchemaMinLength] :: ParamSchema t -> Maybe Integer
[_paramSchemaPattern] :: ParamSchema t -> Maybe Pattern
[_paramSchemaMaxItems] :: ParamSchema t -> Maybe Integer
[_paramSchemaMinItems] :: ParamSchema t -> Maybe Integer
[_paramSchemaUniqueItems] :: ParamSchema t -> Maybe Bool
[_paramSchemaEnum] :: ParamSchema t -> Maybe [Value]
[_paramSchemaMultipleOf] :: ParamSchema t -> Maybe Scientific
data Xml
Xml :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> Xml

-- | Replaces the name of the element/attribute used for the described
--   schema property. When defined within the <tt><a>SwaggerItems</a></tt>
--   (items), it will affect the name of the individual XML elements within
--   the list. When defined alongside type being array (outside the items),
--   it will affect the wrapping element and only if wrapped is true. If
--   wrapped is false, it will be ignored.
[_xmlName] :: Xml -> Maybe Text

-- | The URL of the namespace definition. Value SHOULD be in the form of a
--   URL.
[_xmlNamespace] :: Xml -> Maybe Text

-- | The prefix to be used for the name.
[_xmlPrefix] :: Xml -> Maybe Text

-- | Declares whether the property definition translates to an attribute
--   instead of an element. Default value is <tt>False</tt>.
[_xmlAttribute] :: Xml -> Maybe Bool

-- | MAY be used only for an array definition. Signifies whether the array
--   is wrapped (for example,
--   <tt>&lt;books&gt;&lt;book<i>&gt;&lt;book</i>&gt;&lt;/books&gt;</tt>)
--   or unwrapped (<tt>&lt;book<i>&gt;&lt;book</i>&gt;</tt>). Default value
--   is <tt>False</tt>. The definition takes effect only when defined
--   alongside type being array (outside the items).
[_xmlWrapped] :: Xml -> Maybe Bool

-- | A container for the expected responses of an operation. The container
--   maps a HTTP response code to the expected response. It is not expected
--   from the documentation to necessarily cover all possible HTTP response
--   codes, since they may not be known in advance. However, it is expected
--   from the documentation to cover a successful operation response and
--   any known errors.
data Responses
Responses :: Maybe (Referenced Response) -> HashMap HttpStatusCode (Referenced Response) -> Responses

-- | The documentation of responses other than the ones declared for
--   specific HTTP response codes. It can be used to cover undeclared
--   responses.
[_responsesDefault] :: Responses -> Maybe (Referenced Response)

-- | Any HTTP status code can be used as the property name (one property
--   per HTTP status code). Describes the expected response for those HTTP
--   status codes.
[_responsesResponses] :: Responses -> HashMap HttpStatusCode (Referenced Response)
type HttpStatusCode = Int

-- | Describes a single response from an API Operation.
data Response
Response :: Text -> Maybe (Referenced Schema) -> HashMap HeaderName Header -> Maybe Example -> Response

-- | A short description of the response. GFM syntax can be used for rich
--   text representation.
[_responseDescription] :: Response -> Text

-- | A definition of the response structure. It can be a primitive, an
--   array or an object. If this field does not exist, it means no content
--   is returned as part of the response. As an extension to the Schema
--   Object, its root type value may also be "file". This SHOULD be
--   accompanied by a relevant produces mime-type.
[_responseSchema] :: Response -> Maybe (Referenced Schema)

-- | A list of headers that are sent with the response.
[_responseHeaders] :: Response -> HashMap HeaderName Header

-- | An example of the response message.
[_responseExamples] :: Response -> Maybe Example
type HeaderName = Text
data Header
Header :: Maybe Text -> ParamSchema Header -> Header

-- | A short description of the header.
[_headerDescription] :: Header -> Maybe Text
[_headerParamSchema] :: Header -> ParamSchema Header
data Example
Example :: Map MediaType Value -> Example
[getExample] :: Example -> Map MediaType Value
exampleConstr :: Constr
exampleDataType :: DataType

-- | The location of the API key.
data ApiKeyLocation
ApiKeyQuery :: ApiKeyLocation
ApiKeyHeader :: ApiKeyLocation
data ApiKeyParams
ApiKeyParams :: Text -> ApiKeyLocation -> ApiKeyParams

-- | The name of the header or query parameter to be used.
[_apiKeyName] :: ApiKeyParams -> Text

-- | The location of the API key.
[_apiKeyIn] :: ApiKeyParams -> ApiKeyLocation

-- | The authorization URL to be used for OAuth2 flow. This SHOULD be in
--   the form of a URL.
type AuthorizationURL = Text

-- | The token URL to be used for OAuth2 flow. This SHOULD be in the form
--   of a URL.
type TokenURL = Text
data OAuth2Flow
OAuth2Implicit :: AuthorizationURL -> OAuth2Flow
OAuth2Password :: TokenURL -> OAuth2Flow
OAuth2Application :: TokenURL -> OAuth2Flow
OAuth2AccessCode :: AuthorizationURL -> TokenURL -> OAuth2Flow
data OAuth2Params
OAuth2Params :: OAuth2Flow -> HashMap Text Text -> OAuth2Params

-- | The flow used by the OAuth2 security scheme.
[_oauth2Flow] :: OAuth2Params -> OAuth2Flow

-- | The available scopes for the OAuth2 security scheme.
[_oauth2Scopes] :: OAuth2Params -> HashMap Text Text
data SecuritySchemeType
SecuritySchemeBasic :: SecuritySchemeType
SecuritySchemeApiKey :: ApiKeyParams -> SecuritySchemeType
SecuritySchemeOAuth2 :: OAuth2Params -> SecuritySchemeType
data SecurityScheme
SecurityScheme :: SecuritySchemeType -> Maybe Text -> SecurityScheme

-- | The type of the security scheme.
[_securitySchemeType] :: SecurityScheme -> SecuritySchemeType

-- | A short description for security scheme.
[_securitySchemeDescription] :: SecurityScheme -> Maybe Text

-- | Lists the required security schemes to execute this operation. The
--   object can have multiple security schemes declared in it which are all
--   required (that is, there is a logical AND between the schemes).
newtype SecurityRequirement
SecurityRequirement :: HashMap Text [Text] -> SecurityRequirement
[getSecurityRequirement] :: SecurityRequirement -> HashMap Text [Text]

-- | Tag name.
type TagName = Text

-- | Allows adding meta data to a single tag that is used by
--   <tt>Operation</tt>. It is not mandatory to have a <tt>Tag</tt> per tag
--   used there.
data Tag
Tag :: TagName -> Maybe Text -> Maybe ExternalDocs -> Tag

-- | The name of the tag.
[_tagName] :: Tag -> TagName

-- | A short description for the tag. GFM syntax can be used for rich text
--   representation.
[_tagDescription] :: Tag -> Maybe Text

-- | Additional external documentation for this tag.
[_tagExternalDocs] :: Tag -> Maybe ExternalDocs

-- | Allows referencing an external resource for extended documentation.
data ExternalDocs
ExternalDocs :: Maybe Text -> URL -> ExternalDocs

-- | A short description of the target documentation. GFM syntax can be
--   used for rich text representation.
[_externalDocsDescription] :: ExternalDocs -> Maybe Text

-- | The URL for the target documentation.
[_externalDocsUrl] :: ExternalDocs -> URL

-- | A simple object to allow referencing other definitions in the
--   specification. It can be used to reference parameters and responses
--   that are defined at the top level for reuse.
newtype Reference
Reference :: Text -> Reference
[getReference] :: Reference -> Text
data Referenced a
Ref :: Reference -> Referenced a
Inline :: a -> Referenced a
newtype URL
URL :: Text -> URL
[getUrl] :: URL -> Text
referencedToJSON :: ToJSON a => Text -> Referenced a -> Value
referencedParseJSON :: FromJSON a => Text -> Value -> Parser (Referenced a)
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_13Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_12Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_11Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_10Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_9Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_8Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_7Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_6Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_5Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Swagger
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Swagger
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Swagger
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_5Info
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4Info
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Info
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Info
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Info
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Info
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Info
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Info
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Contact
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Contact
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Contact
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Contact
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Contact
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1License
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0License
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0License
instance GHC.Generics.Datatype Data.Swagger.Internal.D1License
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_7PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_6PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_5PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0PathItem
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0PathItem
instance GHC.Generics.Datatype Data.Swagger.Internal.D1PathItem
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_11Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_10Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_9Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_8Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_7Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_6Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_5Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Operation
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Operation
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Operation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Param
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Param
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Param
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Param
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Param
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Param
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_1ParamAnySchema
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ParamAnySchema
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ParamAnySchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Responses
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Responses
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Responses
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Responses
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Response
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Response
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Response
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Response
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Response
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Response
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Header
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Header
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Header
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Header
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1NamedSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0NamedSchema
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0NamedSchema
instance GHC.Generics.Datatype Data.Swagger.Internal.D1NamedSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2ParamOtherSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1ParamOtherSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0ParamOtherSchema
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ParamOtherSchema
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ParamOtherSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_15ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_14ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_13ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_12ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_11ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_10ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_9ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_8ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_7ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_6ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_5ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0ParamSchema
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ParamSchema
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ParamSchema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_13Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_12Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_11Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_10Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_9Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_8Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_7Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_6Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_5Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Schema
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Schema
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Schema
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Tag
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Tag
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Tag
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Tag
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Tag
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1ExternalDocs
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0ExternalDocs
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ExternalDocs
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ExternalDocs
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1SecurityScheme
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0SecurityScheme
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0SecurityScheme
instance GHC.Generics.Datatype Data.Swagger.Internal.D1SecurityScheme
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_2SecuritySchemeType
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_1SecuritySchemeType
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0SecuritySchemeType
instance GHC.Generics.Datatype Data.Swagger.Internal.D1SecuritySchemeType
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1OAuth2Params
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0OAuth2Params
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0OAuth2Params
instance GHC.Generics.Datatype Data.Swagger.Internal.D1OAuth2Params
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_3OAuth2Flow
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_2OAuth2Flow
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_1OAuth2Flow
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0OAuth2Flow
instance GHC.Generics.Datatype Data.Swagger.Internal.D1OAuth2Flow
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1ApiKeyParams
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0ApiKeyParams
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ApiKeyParams
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ApiKeyParams
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_1ApiKeyLocation
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ApiKeyLocation
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ApiKeyLocation
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Example
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Example
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Example
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_4Xml
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_3Xml
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_2Xml
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Xml
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Xml
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Xml
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Xml
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_3ParamLocation
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_2ParamLocation
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_1ParamLocation
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0ParamLocation
instance GHC.Generics.Datatype Data.Swagger.Internal.D1ParamLocation
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_3Scheme
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_2Scheme
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_1Scheme
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Scheme
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Scheme
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_1Host
instance GHC.Generics.Selector Data.Swagger.Internal.S1_0_0Host
instance GHC.Generics.Constructor Data.Swagger.Internal.C1_0Host
instance GHC.Generics.Datatype Data.Swagger.Internal.D1Host
instance Data.Data.Data Data.Swagger.Internal.Swagger
instance GHC.Generics.Generic Data.Swagger.Internal.Swagger
instance GHC.Show.Show Data.Swagger.Internal.Swagger
instance GHC.Classes.Eq Data.Swagger.Internal.Swagger
instance Data.Data.Data Data.Swagger.Internal.Info
instance GHC.Generics.Generic Data.Swagger.Internal.Info
instance GHC.Show.Show Data.Swagger.Internal.Info
instance GHC.Classes.Eq Data.Swagger.Internal.Info
instance Data.Data.Data Data.Swagger.Internal.Contact
instance GHC.Generics.Generic Data.Swagger.Internal.Contact
instance GHC.Show.Show Data.Swagger.Internal.Contact
instance GHC.Classes.Eq Data.Swagger.Internal.Contact
instance Data.Data.Data Data.Swagger.Internal.License
instance GHC.Generics.Generic Data.Swagger.Internal.License
instance GHC.Show.Show Data.Swagger.Internal.License
instance GHC.Classes.Eq Data.Swagger.Internal.License
instance Data.Data.Data Data.Swagger.Internal.PathItem
instance GHC.Generics.Generic Data.Swagger.Internal.PathItem
instance GHC.Show.Show Data.Swagger.Internal.PathItem
instance GHC.Classes.Eq Data.Swagger.Internal.PathItem
instance Data.Data.Data Data.Swagger.Internal.Operation
instance GHC.Generics.Generic Data.Swagger.Internal.Operation
instance GHC.Show.Show Data.Swagger.Internal.Operation
instance GHC.Classes.Eq Data.Swagger.Internal.Operation
instance Data.Data.Data Data.Swagger.Internal.Param
instance GHC.Generics.Generic Data.Swagger.Internal.Param
instance GHC.Show.Show Data.Swagger.Internal.Param
instance GHC.Classes.Eq Data.Swagger.Internal.Param
instance Data.Data.Data Data.Swagger.Internal.ParamAnySchema
instance GHC.Generics.Generic Data.Swagger.Internal.ParamAnySchema
instance GHC.Show.Show Data.Swagger.Internal.ParamAnySchema
instance GHC.Classes.Eq Data.Swagger.Internal.ParamAnySchema
instance Data.Data.Data Data.Swagger.Internal.Responses
instance GHC.Generics.Generic Data.Swagger.Internal.Responses
instance GHC.Show.Show Data.Swagger.Internal.Responses
instance GHC.Classes.Eq Data.Swagger.Internal.Responses
instance Data.Data.Data Data.Swagger.Internal.Response
instance GHC.Generics.Generic Data.Swagger.Internal.Response
instance GHC.Show.Show Data.Swagger.Internal.Response
instance GHC.Classes.Eq Data.Swagger.Internal.Response
instance Data.Data.Data Data.Swagger.Internal.Header
instance GHC.Generics.Generic Data.Swagger.Internal.Header
instance GHC.Show.Show Data.Swagger.Internal.Header
instance GHC.Classes.Eq Data.Swagger.Internal.Header
instance Data.Data.Data Data.Swagger.Internal.NamedSchema
instance GHC.Generics.Generic Data.Swagger.Internal.NamedSchema
instance GHC.Show.Show Data.Swagger.Internal.NamedSchema
instance GHC.Classes.Eq Data.Swagger.Internal.NamedSchema
instance Data.Data.Data Data.Swagger.Internal.ParamOtherSchema
instance GHC.Generics.Generic Data.Swagger.Internal.ParamOtherSchema
instance GHC.Show.Show Data.Swagger.Internal.ParamOtherSchema
instance GHC.Classes.Eq Data.Swagger.Internal.ParamOtherSchema
instance GHC.Generics.Generic (Data.Swagger.Internal.ParamSchema t)
instance GHC.Show.Show (Data.Swagger.Internal.ParamSchema t)
instance GHC.Classes.Eq (Data.Swagger.Internal.ParamSchema t)
instance Data.Data.Data Data.Swagger.Internal.Schema
instance GHC.Generics.Generic Data.Swagger.Internal.Schema
instance GHC.Show.Show Data.Swagger.Internal.Schema
instance GHC.Classes.Eq Data.Swagger.Internal.Schema
instance Data.Data.Data Data.Swagger.Internal.Tag
instance GHC.Generics.Generic Data.Swagger.Internal.Tag
instance GHC.Show.Show Data.Swagger.Internal.Tag
instance GHC.Classes.Eq Data.Swagger.Internal.Tag
instance Data.Data.Data Data.Swagger.Internal.ExternalDocs
instance GHC.Generics.Generic Data.Swagger.Internal.ExternalDocs
instance GHC.Show.Show Data.Swagger.Internal.ExternalDocs
instance GHC.Classes.Eq Data.Swagger.Internal.ExternalDocs
instance Data.Data.Data Data.Swagger.Internal.URL
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.URL
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.URL
instance GHC.Show.Show Data.Swagger.Internal.URL
instance GHC.Classes.Eq Data.Swagger.Internal.URL
instance Data.Data.Data a => Data.Data.Data (Data.Swagger.Internal.Referenced a)
instance GHC.Base.Functor Data.Swagger.Internal.Referenced
instance GHC.Show.Show a => GHC.Show.Show (Data.Swagger.Internal.Referenced a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Swagger.Internal.Referenced a)
instance Data.Data.Data Data.Swagger.Internal.Reference
instance GHC.Show.Show Data.Swagger.Internal.Reference
instance GHC.Classes.Eq Data.Swagger.Internal.Reference
instance Data.Data.Data Data.Swagger.Internal.SecurityRequirement
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.SecurityRequirement
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.SecurityRequirement
instance GHC.Base.Monoid Data.Swagger.Internal.SecurityRequirement
instance GHC.Show.Show Data.Swagger.Internal.SecurityRequirement
instance GHC.Read.Read Data.Swagger.Internal.SecurityRequirement
instance GHC.Classes.Eq Data.Swagger.Internal.SecurityRequirement
instance Data.Data.Data Data.Swagger.Internal.SecurityScheme
instance GHC.Generics.Generic Data.Swagger.Internal.SecurityScheme
instance GHC.Show.Show Data.Swagger.Internal.SecurityScheme
instance GHC.Classes.Eq Data.Swagger.Internal.SecurityScheme
instance Data.Data.Data Data.Swagger.Internal.SecuritySchemeType
instance GHC.Generics.Generic Data.Swagger.Internal.SecuritySchemeType
instance GHC.Show.Show Data.Swagger.Internal.SecuritySchemeType
instance GHC.Classes.Eq Data.Swagger.Internal.SecuritySchemeType
instance Data.Data.Data Data.Swagger.Internal.OAuth2Params
instance GHC.Generics.Generic Data.Swagger.Internal.OAuth2Params
instance GHC.Show.Show Data.Swagger.Internal.OAuth2Params
instance GHC.Classes.Eq Data.Swagger.Internal.OAuth2Params
instance Data.Data.Data Data.Swagger.Internal.OAuth2Flow
instance GHC.Generics.Generic Data.Swagger.Internal.OAuth2Flow
instance GHC.Show.Show Data.Swagger.Internal.OAuth2Flow
instance GHC.Classes.Eq Data.Swagger.Internal.OAuth2Flow
instance Data.Data.Data Data.Swagger.Internal.ApiKeyParams
instance GHC.Generics.Generic Data.Swagger.Internal.ApiKeyParams
instance GHC.Show.Show Data.Swagger.Internal.ApiKeyParams
instance GHC.Classes.Eq Data.Swagger.Internal.ApiKeyParams
instance Data.Data.Data Data.Swagger.Internal.ApiKeyLocation
instance GHC.Generics.Generic Data.Swagger.Internal.ApiKeyLocation
instance GHC.Show.Show Data.Swagger.Internal.ApiKeyLocation
instance GHC.Classes.Eq Data.Swagger.Internal.ApiKeyLocation
instance GHC.Generics.Generic Data.Swagger.Internal.Example
instance GHC.Show.Show Data.Swagger.Internal.Example
instance GHC.Classes.Eq Data.Swagger.Internal.Example
instance Data.Data.Data Data.Swagger.Internal.Xml
instance GHC.Generics.Generic Data.Swagger.Internal.Xml
instance GHC.Show.Show Data.Swagger.Internal.Xml
instance GHC.Classes.Eq Data.Swagger.Internal.Xml
instance Data.Data.Data Data.Swagger.Internal.ParamLocation
instance GHC.Generics.Generic Data.Swagger.Internal.ParamLocation
instance GHC.Show.Show Data.Swagger.Internal.ParamLocation
instance GHC.Classes.Eq Data.Swagger.Internal.ParamLocation
instance GHC.Base.Monoid Data.Swagger.Internal.MimeList
instance GHC.Show.Show Data.Swagger.Internal.MimeList
instance GHC.Classes.Eq Data.Swagger.Internal.MimeList
instance Data.Data.Data Data.Swagger.Internal.Scheme
instance GHC.Generics.Generic Data.Swagger.Internal.Scheme
instance GHC.Show.Show Data.Swagger.Internal.Scheme
instance GHC.Classes.Eq Data.Swagger.Internal.Scheme
instance GHC.Generics.Generic Data.Swagger.Internal.Host
instance GHC.Show.Show Data.Swagger.Internal.Host
instance GHC.Classes.Eq Data.Swagger.Internal.Host
instance GHC.Classes.Eq (Data.Swagger.Internal.SwaggerItems t)
instance GHC.Show.Show (Data.Swagger.Internal.SwaggerItems t)
instance Data.Data.Data (Data.Swagger.Internal.SwaggerItems Data.Swagger.Internal.Schema)
instance GHC.Classes.Eq (Data.Swagger.Internal.SwaggerType t)
instance GHC.Show.Show (Data.Swagger.Internal.SwaggerType t)
instance GHC.Classes.Eq (Data.Swagger.Internal.CollectionFormat t)
instance GHC.Show.Show (Data.Swagger.Internal.CollectionFormat t)
instance Data.Data.Data (Data.Swagger.Internal.CollectionFormat Data.Swagger.Internal.ParamOtherSchema)
instance (Data.Data.Data t, Data.Data.Data (Data.Swagger.Internal.SwaggerType t), Data.Data.Data (Data.Swagger.Internal.SwaggerItems t)) => Data.Data.Data (Data.Swagger.Internal.ParamSchema t)
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.URL
instance Data.String.IsString Data.Swagger.Internal.License
instance Data.String.IsString Data.Swagger.Internal.Host
instance Data.Data.Data Data.Swagger.Internal.Host
instance Data.Data.Data Data.Swagger.Internal.MimeList
instance Data.Data.Data t => Data.Data.Data (Data.Swagger.Internal.SwaggerItems t)
instance Data.Typeable.Internal.Typeable t => Data.Data.Data (Data.Swagger.Internal.SwaggerType t)
instance Data.Data.Data (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.ParamOtherSchema)
instance Data.Data.Data (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.Schema)
instance Data.Data.Data t => Data.Data.Data (Data.Swagger.Internal.CollectionFormat t)
instance Data.String.IsString Data.Swagger.Internal.Response
instance Data.Data.Data Data.Swagger.Internal.Example
instance Data.String.IsString Data.Swagger.Internal.Tag
instance Data.String.IsString a => Data.String.IsString (Data.Swagger.Internal.Referenced a)
instance GHC.Base.Monoid Data.Swagger.Internal.Swagger
instance GHC.Base.Monoid Data.Swagger.Internal.Info
instance GHC.Base.Monoid Data.Swagger.Internal.Contact
instance GHC.Base.Monoid Data.Swagger.Internal.PathItem
instance GHC.Base.Monoid Data.Swagger.Internal.Schema
instance GHC.Base.Monoid (Data.Swagger.Internal.ParamSchema t)
instance GHC.Base.Monoid Data.Swagger.Internal.Param
instance GHC.Base.Monoid Data.Swagger.Internal.ParamOtherSchema
instance GHC.Base.Monoid Data.Swagger.Internal.Header
instance GHC.Base.Monoid Data.Swagger.Internal.Responses
instance GHC.Base.Monoid Data.Swagger.Internal.Response
instance GHC.Base.Monoid Data.Swagger.Internal.ExternalDocs
instance GHC.Base.Monoid Data.Swagger.Internal.Operation
instance GHC.Base.Monoid Data.Swagger.Internal.Example
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.Info
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.PathItem
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.Schema
instance Data.Swagger.Internal.Utils.SwaggerMonoid (Data.Swagger.Internal.ParamSchema t)
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.Param
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.ParamOtherSchema
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.Responses
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.Response
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.ExternalDocs
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.Operation
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.MimeList
instance Data.Swagger.Internal.Utils.SwaggerMonoid (Data.Swagger.Internal.SwaggerType t)
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.ParamLocation
instance Data.Swagger.Internal.Utils.SwaggerMonoid (Data.HashMap.Base.HashMap GHC.IO.FilePath Data.Swagger.Internal.PathItem)
instance GHC.Base.Monoid a => Data.Swagger.Internal.Utils.SwaggerMonoid (Data.Swagger.Internal.Referenced a)
instance Data.Swagger.Internal.Utils.SwaggerMonoid Data.Swagger.Internal.ParamAnySchema
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.ParamLocation
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Info
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Contact
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.License
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.ApiKeyLocation
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.ApiKeyParams
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Scheme
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Tag
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.ExternalDocs
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Xml
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.ParamLocation
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Info
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Contact
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.License
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.ApiKeyLocation
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.ApiKeyParams
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Scheme
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Tag
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.ExternalDocs
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.OAuth2Flow
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.OAuth2Params
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.SecuritySchemeType
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Swagger
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.SecurityScheme
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Schema
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Header
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.SwaggerItems t)
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Host
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.MimeList
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Param
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.ParamAnySchema
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.ParamOtherSchema
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Responses
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Response
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Operation
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.PathItem
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Example
instance Data.Aeson.Types.Class.ToJSON Data.Swagger.Internal.Reference
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Schema)
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Param)
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Response)
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.SwaggerType t)
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.CollectionFormat t)
instance Data.Aeson.Types.Class.ToJSON (Data.Swagger.Internal.ParamSchema t)
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.OAuth2Flow
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.OAuth2Params
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.SecuritySchemeType
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Swagger
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.SecurityScheme
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Schema
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Header
instance (Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.CollectionFormat t), Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.ParamSchema t)) => Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerItems t)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerItems Data.Swagger.Internal.Schema)
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Host
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.MimeList
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Param
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.ParamAnySchema
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.ParamOtherSchema
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Responses
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Example
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Response
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Operation
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.PathItem
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Reference
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Schema)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Param)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Response)
instance Data.Aeson.Types.Class.FromJSON Data.Swagger.Internal.Xml
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.Schema)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.ParamOtherSchema)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerType t)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.CollectionFormat t)
instance Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.CollectionFormat Data.Swagger.Internal.ParamOtherSchema)
instance (Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerType t), Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.SwaggerItems t)) => Data.Aeson.Types.Class.FromJSON (Data.Swagger.Internal.ParamSchema t)

module Data.Swagger.Lens
class HasBasePath s a | s -> a
basePath :: HasBasePath s a => Lens' s a
class HasConsumes s a | s -> a
consumes :: HasConsumes s a => Lens' s a
class HasDefinitions s a | s -> a
definitions :: HasDefinitions s a => Lens' s a
class HasExternalDocs s a | s -> a
externalDocs :: HasExternalDocs s a => Lens' s a
class HasHost s a | s -> a
host :: HasHost s a => Lens' s a
class HasInfo s a | s -> a
info :: HasInfo s a => Lens' s a
class HasParameters s a | s -> a
parameters :: HasParameters s a => Lens' s a
class HasPaths s a | s -> a
paths :: HasPaths s a => Lens' s a
class HasProduces s a | s -> a
produces :: HasProduces s a => Lens' s a
class HasResponses s a | s -> a
responses :: HasResponses s a => Lens' s a
class HasSchemes s a | s -> a
schemes :: HasSchemes s a => Lens' s a
class HasSecurity s a | s -> a
security :: HasSecurity s a => Lens' s a
class HasSecurityDefinitions s a | s -> a
securityDefinitions :: HasSecurityDefinitions s a => Lens' s a
class HasTags s a | s -> a
tags :: HasTags s a => Lens' s a
class HasName s a | s -> a
name :: HasName s a => Lens' s a
class HasPort s a | s -> a
port :: HasPort s a => Lens' s a
class HasContact s a | s -> a
contact :: HasContact s a => Lens' s a
class HasDescription s a | s -> a
description :: HasDescription s a => Lens' s a
class HasLicense s a | s -> a
license :: HasLicense s a => Lens' s a
class HasTermsOfService s a | s -> a
termsOfService :: HasTermsOfService s a => Lens' s a
class HasTitle s a | s -> a
title :: HasTitle s a => Lens' s a
class HasVersion s a | s -> a
version :: HasVersion s a => Lens' s a
class HasEmail s a | s -> a
email :: HasEmail s a => Lens' s a
class HasUrl s a | s -> a
url :: HasUrl s a => Lens' s a
class HasDelete s a | s -> a
delete :: HasDelete s a => Lens' s a
class HasGet s a | s -> a
get :: HasGet s a => Lens' s a
class HasHead s a | s -> a
head :: HasHead s a => Lens' s a
class HasOptions s a | s -> a
options :: HasOptions s a => Lens' s a
class HasPatch s a | s -> a
patch :: HasPatch s a => Lens' s a
class HasPost s a | s -> a
post :: HasPost s a => Lens' s a
class HasPut s a | s -> a
put :: HasPut s a => Lens' s a
class HasDeprecated s a | s -> a
deprecated :: HasDeprecated s a => Lens' s a
class HasOperationId s a | s -> a
operationId :: HasOperationId s a => Lens' s a
class HasSummary s a | s -> a
summary :: HasSummary s a => Lens' s a
class HasRequired s a | s -> a
required :: HasRequired s a => Lens' s a
class HasSchema s a | s -> a
schema :: HasSchema s a => Lens' s a
class HasAllowEmptyValue s a | s -> a
allowEmptyValue :: HasAllowEmptyValue s a => Lens' s a
class HasIn s a | s -> a
in_ :: HasIn s a => Lens' s a
class HasParamSchema s a | s -> a
paramSchema :: HasParamSchema s a => Lens' s a
class HasAdditionalProperties s a | s -> a
additionalProperties :: HasAdditionalProperties s a => Lens' s a
class HasAllOf s a | s -> a
allOf :: HasAllOf s a => Lens' s a
class HasDiscriminator s a | s -> a
discriminator :: HasDiscriminator s a => Lens' s a
class HasExample s a | s -> a
example :: HasExample s a => Lens' s a
class HasMaxProperties s a | s -> a
maxProperties :: HasMaxProperties s a => Lens' s a
class HasMinProperties s a | s -> a
minProperties :: HasMinProperties s a => Lens' s a
class HasProperties s a | s -> a
properties :: HasProperties s a => Lens' s a
class HasReadOnly s a | s -> a
readOnly :: HasReadOnly s a => Lens' s a
class HasXml s a | s -> a
xml :: HasXml s a => Lens' s a
class HasDefault s a | s -> a
default_ :: HasDefault s a => Lens' s a
class HasEnum s a | s -> a
enum_ :: HasEnum s a => Lens' s a
class HasExclusiveMaximum s a | s -> a
exclusiveMaximum :: HasExclusiveMaximum s a => Lens' s a
class HasExclusiveMinimum s a | s -> a
exclusiveMinimum :: HasExclusiveMinimum s a => Lens' s a
class HasFormat s a | s -> a
format :: HasFormat s a => Lens' s a
class HasItems s a | s -> a
items :: HasItems s a => Lens' s a
class HasMaxItems s a | s -> a
maxItems :: HasMaxItems s a => Lens' s a
class HasMaxLength s a | s -> a
maxLength :: HasMaxLength s a => Lens' s a
class HasMaximum s a | s -> a
maximum_ :: HasMaximum s a => Lens' s a
class HasMinItems s a | s -> a
minItems :: HasMinItems s a => Lens' s a
class HasMinLength s a | s -> a
minLength :: HasMinLength s a => Lens' s a
class HasMinimum s a | s -> a
minimum_ :: HasMinimum s a => Lens' s a
class HasMultipleOf s a | s -> a
multipleOf :: HasMultipleOf s a => Lens' s a
class HasPattern s a | s -> a
pattern :: HasPattern s a => Lens' s a
class HasType s a | s -> a
type_ :: HasType s a => Lens' s a
class HasUniqueItems s a | s -> a
uniqueItems :: HasUniqueItems s a => Lens' s a
class HasAttribute s a | s -> a
attribute :: HasAttribute s a => Lens' s a
class HasNamespace s a | s -> a
namespace :: HasNamespace s a => Lens' s a
class HasPrefix s a | s -> a
prefix :: HasPrefix s a => Lens' s a
class HasWrapped s a | s -> a
wrapped :: HasWrapped s a => Lens' s a
class HasExamples s a | s -> a
examples :: HasExamples s a => Lens' s a
class HasHeaders s a | s -> a
headers :: HasHeaders s a => Lens' s a
_ParamOther :: Prism' ParamAnySchema ParamOtherSchema
_ParamBody :: Prism' ParamAnySchema (Referenced Schema)
_SecuritySchemeOAuth2 :: Prism' SecuritySchemeType OAuth2Params
_SecuritySchemeApiKey :: Prism' SecuritySchemeType ApiKeyParams
_SecuritySchemeBasic :: Prism' SecuritySchemeType ()
_Inline :: Prism (Referenced a_a6mDQ) (Referenced a_aFk3) a_a6mDQ a_aFk3
_Ref :: Prism' (Referenced a_aFk3) Reference
_SwaggerItemsArray :: (t ~ Schema) => Review (SwaggerItems t) [Referenced Schema]
_SwaggerItemsObject :: (t ~ Schema) => Review (SwaggerItems t) (Referenced Schema)
_SwaggerItemsPrimitive :: (Profunctor p, Bifunctor p, Functor f) => Optic' p f (SwaggerItems t) (Maybe (CollectionFormat t), ParamSchema t)
instance Control.Lens.At.Ixed Data.Swagger.Internal.Responses
instance Control.Lens.At.At Data.Swagger.Internal.Responses
instance Control.Lens.At.Ixed Data.Swagger.Internal.Operation
instance Control.Lens.At.At Data.Swagger.Internal.Operation
instance Data.Swagger.Lens.HasParamSchema Data.Swagger.Internal.NamedSchema (Data.Swagger.Internal.ParamSchema Data.Swagger.Internal.Schema)
instance Data.Swagger.Lens.HasType Data.Swagger.Internal.Header (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.Header)
instance Data.Swagger.Lens.HasType Data.Swagger.Internal.Schema (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.Schema)
instance Data.Swagger.Lens.HasType Data.Swagger.Internal.NamedSchema (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.Schema)
instance Data.Swagger.Lens.HasType Data.Swagger.Internal.ParamOtherSchema (Data.Swagger.Internal.SwaggerType Data.Swagger.Internal.ParamOtherSchema)
instance Data.Swagger.Lens.HasDefault Data.Swagger.Internal.Header (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
instance Data.Swagger.Lens.HasDefault Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
instance Data.Swagger.Lens.HasDefault Data.Swagger.Internal.ParamOtherSchema (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasFormat s (GHC.Base.Maybe Data.Swagger.Internal.Format)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasItems s (GHC.Base.Maybe (Data.Swagger.Internal.SwaggerItems t))
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMaximum s (GHC.Base.Maybe Data.Scientific.Scientific)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasExclusiveMaximum s (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMinimum s (GHC.Base.Maybe Data.Scientific.Scientific)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasExclusiveMinimum s (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMaxLength s (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMinLength s (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasPattern s (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMaxItems s (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMinItems s (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasUniqueItems s (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasEnum s (GHC.Base.Maybe [Data.Aeson.Types.Internal.Value])
instance Data.Swagger.Lens.HasParamSchema s (Data.Swagger.Internal.ParamSchema t) => Data.Swagger.Lens.HasMultipleOf s (GHC.Base.Maybe Data.Scientific.Scientific)
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.ExternalDocs (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasUrl Data.Swagger.Internal.ExternalDocs Data.Swagger.Internal.URL
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.SecurityScheme (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasType Data.Swagger.Internal.SecurityScheme Data.Swagger.Internal.SecuritySchemeType
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Response Data.Text.Internal.Text
instance Data.Swagger.Lens.HasExamples Data.Swagger.Internal.Response (GHC.Base.Maybe Data.Swagger.Internal.Example)
instance Data.Swagger.Lens.HasHeaders Data.Swagger.Internal.Response (Data.HashMap.Base.HashMap Data.Swagger.Internal.HeaderName Data.Swagger.Internal.Header)
instance Data.Swagger.Lens.HasSchema Data.Swagger.Internal.Response (GHC.Base.Maybe (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Schema))
instance Data.Swagger.Lens.HasDefault Data.Swagger.Internal.Responses (GHC.Base.Maybe (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Response))
instance Data.Swagger.Lens.HasResponses Data.Swagger.Internal.Responses (Data.HashMap.Base.HashMap Data.Swagger.Internal.HttpStatusCode (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Response))
instance Data.Swagger.Lens.HasAttribute Data.Swagger.Internal.Xml (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.Xml (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasNamespace Data.Swagger.Internal.Xml (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasPrefix Data.Swagger.Internal.Xml (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasWrapped Data.Swagger.Internal.Xml (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasDefault (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
instance Data.Swagger.Lens.HasEnum (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe [Data.Aeson.Types.Internal.Value])
instance Data.Swagger.Lens.HasExclusiveMaximum (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasExclusiveMinimum (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasFormat (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe Data.Swagger.Internal.Format)
instance Data.Swagger.Lens.HasItems (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe (Data.Swagger.Internal.SwaggerItems t0))
instance Data.Swagger.Lens.HasMaxItems (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasMaxLength (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasMaximum (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe Data.Scientific.Scientific)
instance Data.Swagger.Lens.HasMinItems (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasMinLength (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasMinimum (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe Data.Scientific.Scientific)
instance Data.Swagger.Lens.HasMultipleOf (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe Data.Scientific.Scientific)
instance Data.Swagger.Lens.HasPattern (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe Data.Swagger.Internal.Pattern)
instance Data.Swagger.Lens.HasType (Data.Swagger.Internal.ParamSchema t0) (Data.Swagger.Internal.SwaggerType t0)
instance Data.Swagger.Lens.HasUniqueItems (Data.Swagger.Internal.ParamSchema t0) (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.NamedSchema (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasSchema Data.Swagger.Internal.NamedSchema Data.Swagger.Internal.Schema
instance Data.Swagger.Lens.HasAdditionalProperties Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Swagger.Internal.Schema)
instance Data.Swagger.Lens.HasAllOf Data.Swagger.Internal.Schema (GHC.Base.Maybe [Data.Swagger.Internal.Schema])
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasDiscriminator Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasExample Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Aeson.Types.Internal.Value)
instance Data.Swagger.Lens.HasExternalDocs Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Swagger.Internal.ExternalDocs)
instance Data.Swagger.Lens.HasMaxProperties Data.Swagger.Internal.Schema (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasMinProperties Data.Swagger.Internal.Schema (GHC.Base.Maybe GHC.Integer.Type.Integer)
instance Data.Swagger.Lens.HasParamSchema Data.Swagger.Internal.Schema (Data.Swagger.Internal.ParamSchema Data.Swagger.Internal.Schema)
instance Data.Swagger.Lens.HasProperties Data.Swagger.Internal.Schema (Data.HashMap.Base.HashMap Data.Text.Internal.Text (Data.Swagger.Internal.Referenced Data.Swagger.Internal.Schema))
instance Data.Swagger.Lens.HasReadOnly Data.Swagger.Internal.Schema (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasRequired Data.Swagger.Internal.Schema [Data.Swagger.Internal.ParamName]
instance Data.Swagger.Lens.HasTitle Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasXml Data.Swagger.Internal.Schema (GHC.Base.Maybe Data.Swagger.Internal.Xml)
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Header (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasParamSchema Data.Swagger.Internal.Header (Data.Swagger.Internal.ParamSchema Data.Swagger.Internal.Header)
instance Data.Swagger.Lens.HasAllowEmptyValue Data.Swagger.Internal.ParamOtherSchema (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasIn Data.Swagger.Internal.ParamOtherSchema Data.Swagger.Internal.ParamLocation
instance Data.Swagger.Lens.HasParamSchema Data.Swagger.Internal.ParamOtherSchema (Data.Swagger.Internal.ParamSchema Data.Swagger.Internal.ParamOtherSchema)
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Param (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.Param Data.Text.Internal.Text
instance Data.Swagger.Lens.HasRequired Data.Swagger.Internal.Param (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasSchema Data.Swagger.Internal.Param Data.Swagger.Internal.ParamAnySchema
instance Data.Swagger.Lens.HasConsumes Data.Swagger.Internal.Operation (GHC.Base.Maybe Data.Swagger.Internal.MimeList)
instance Data.Swagger.Lens.HasDeprecated Data.Swagger.Internal.Operation (GHC.Base.Maybe GHC.Types.Bool)
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Operation (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasExternalDocs Data.Swagger.Internal.Operation (GHC.Base.Maybe Data.Swagger.Internal.ExternalDocs)
instance Data.Swagger.Lens.HasOperationId Data.Swagger.Internal.Operation (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasParameters Data.Swagger.Internal.Operation [Data.Swagger.Internal.Referenced Data.Swagger.Internal.Param]
instance Data.Swagger.Lens.HasProduces Data.Swagger.Internal.Operation (GHC.Base.Maybe Data.Swagger.Internal.MimeList)
instance Data.Swagger.Lens.HasResponses Data.Swagger.Internal.Operation Data.Swagger.Internal.Responses
instance Data.Swagger.Lens.HasSchemes Data.Swagger.Internal.Operation (GHC.Base.Maybe [Data.Swagger.Internal.Scheme])
instance Data.Swagger.Lens.HasSecurity Data.Swagger.Internal.Operation [Data.Swagger.Internal.SecurityRequirement]
instance Data.Swagger.Lens.HasSummary Data.Swagger.Internal.Operation (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasTags Data.Swagger.Internal.Operation [Data.Swagger.Internal.TagName]
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Tag (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasExternalDocs Data.Swagger.Internal.Tag (GHC.Base.Maybe Data.Swagger.Internal.ExternalDocs)
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.Tag Data.Swagger.Internal.TagName
instance Data.Swagger.Lens.HasDelete Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasGet Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasHead Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasOptions Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasParameters Data.Swagger.Internal.PathItem [Data.Swagger.Internal.Referenced Data.Swagger.Internal.Param]
instance Data.Swagger.Lens.HasPatch Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasPost Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasPut Data.Swagger.Internal.PathItem (GHC.Base.Maybe Data.Swagger.Internal.Operation)
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.License Data.Text.Internal.Text
instance Data.Swagger.Lens.HasUrl Data.Swagger.Internal.License (GHC.Base.Maybe Data.Swagger.Internal.URL)
instance Data.Swagger.Lens.HasEmail Data.Swagger.Internal.Contact (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.Contact (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasUrl Data.Swagger.Internal.Contact (GHC.Base.Maybe Data.Swagger.Internal.URL)
instance Data.Swagger.Lens.HasContact Data.Swagger.Internal.Info (GHC.Base.Maybe Data.Swagger.Internal.Contact)
instance Data.Swagger.Lens.HasDescription Data.Swagger.Internal.Info (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasLicense Data.Swagger.Internal.Info (GHC.Base.Maybe Data.Swagger.Internal.License)
instance Data.Swagger.Lens.HasTermsOfService Data.Swagger.Internal.Info (GHC.Base.Maybe Data.Text.Internal.Text)
instance Data.Swagger.Lens.HasTitle Data.Swagger.Internal.Info Data.Text.Internal.Text
instance Data.Swagger.Lens.HasVersion Data.Swagger.Internal.Info Data.Text.Internal.Text
instance Data.Swagger.Lens.HasName Data.Swagger.Internal.Host Network.Socket.HostName
instance Data.Swagger.Lens.HasPort Data.Swagger.Internal.Host (GHC.Base.Maybe Network.Socket.Types.PortNumber)
instance Data.Swagger.Lens.HasBasePath Data.Swagger.Internal.Swagger (GHC.Base.Maybe GHC.IO.FilePath)
instance Data.Swagger.Lens.HasConsumes Data.Swagger.Internal.Swagger Data.Swagger.Internal.MimeList
instance Data.Swagger.Lens.HasDefinitions Data.Swagger.Internal.Swagger (Data.Swagger.Internal.Definitions Data.Swagger.Internal.Schema)
instance Data.Swagger.Lens.HasExternalDocs Data.Swagger.Internal.Swagger (GHC.Base.Maybe Data.Swagger.Internal.ExternalDocs)
instance Data.Swagger.Lens.HasHost Data.Swagger.Internal.Swagger (GHC.Base.Maybe Data.Swagger.Internal.Host)
instance Data.Swagger.Lens.HasInfo Data.Swagger.Internal.Swagger Data.Swagger.Internal.Info
instance Data.Swagger.Lens.HasParameters Data.Swagger.Internal.Swagger (Data.Swagger.Internal.Definitions Data.Swagger.Internal.Param)
instance Data.Swagger.Lens.HasPaths Data.Swagger.Internal.Swagger (Data.HashMap.Base.HashMap GHC.IO.FilePath Data.Swagger.Internal.PathItem)
instance Data.Swagger.Lens.HasProduces Data.Swagger.Internal.Swagger Data.Swagger.Internal.MimeList
instance Data.Swagger.Lens.HasResponses Data.Swagger.Internal.Swagger (Data.Swagger.Internal.Definitions Data.Swagger.Internal.Response)
instance Data.Swagger.Lens.HasSchemes Data.Swagger.Internal.Swagger (GHC.Base.Maybe [Data.Swagger.Internal.Scheme])
instance Data.Swagger.Lens.HasSecurity Data.Swagger.Internal.Swagger [Data.Swagger.Internal.SecurityRequirement]
instance Data.Swagger.Lens.HasSecurityDefinitions Data.Swagger.Internal.Swagger (Data.Swagger.Internal.Definitions Data.Swagger.Internal.SecurityScheme)
instance Data.Swagger.Lens.HasTags Data.Swagger.Internal.Swagger [Data.Swagger.Internal.Tag]

module Data.Swagger.Internal.ParamSchema

-- | Convert a type into a plain <tt><a>ParamSchema</a></tt>.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   
--   import Control.Lens
--   
--   data Direction = Up | Down
--   
--   instance ToParamSchema Direction where
--     toParamSchema = mempty
--        &amp; type_ .~ SwaggerString
--        &amp; enum_ .~ [ "Up", "Down" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToParamSchema</a></tt>
--   instance you can use a default generic implementation of
--   <tt><a>toParamSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>Generic</a></tt> clause to your
--   datatype and declare a <tt><a>ToParamSchema</a></tt> instance for your
--   datatype without giving definition for <tt><a>toParamSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Direction = Up | Down deriving Generic
--   
--   instance ToParamSchema Direction
--   </pre>
class ToParamSchema a where toParamSchema = genericToParamSchema defaultSchemaOptions

-- | Convert a type into a plain parameter schema.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toParamSchema (Proxy :: Proxy Integer)
--   "{\"type\":\"integer\"}"
--   </pre>
toParamSchema :: ToParamSchema a => proxy a -> ParamSchema t

-- | Default plain schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toParamSchemaBoundedIntegral (Proxy :: Proxy Int8)
--   "{\"maximum\":127,\"minimum\":-128,\"type\":\"integer\"}"
--   </pre>
toParamSchemaBoundedIntegral :: (Bounded a, Integral a) => proxy a -> ParamSchema t
timeParamSchema :: String -> ParamSchema t

-- | Format <tt>"date"</tt> corresponds to <tt>yyyy-mm-dd</tt> format.

-- | <pre>
--   &gt;&gt;&gt; toParamSchema (Proxy :: Proxy LocalTime) ^. format
--   Just "yyyy-mm-ddThh:MM:ss"
--   </pre>

-- | <pre>
--   &gt;&gt;&gt; toParamSchema (Proxy :: Proxy ZonedTime) ^. format
--   Just "yyyy-mm-ddThh:MM:ss+hhMM"
--   </pre>

-- | <pre>
--   &gt;&gt;&gt; toParamSchema (Proxy :: Proxy UTCTime) ^. format
--   Just "yyyy-mm-ddThh:MM:ssZ"
--   </pre>

-- | <pre>
--   &gt;&gt;&gt; encode $ toParamSchema (Proxy :: Proxy ())
--   "{\"type\":\"string\",\"enum\":[\"_\"]}"
--   </pre>

-- | A configurable generic <tt><a>ParamSchema</a></tt> creator.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; data Color = Red | Blue deriving Generic
--   
--   &gt;&gt;&gt; encode $ genericToParamSchema defaultSchemaOptions (Proxy :: Proxy Color)
--   "{\"type\":\"string\",\"enum\":[\"Red\",\"Blue\"]}"
--   </pre>
genericToParamSchema :: (Generic a, GToParamSchema (Rep a)) => SchemaOptions -> proxy a -> ParamSchema t
class GToParamSchema (f :: * -> *)
gtoParamSchema :: GToParamSchema f => SchemaOptions -> proxy f -> ParamSchema t -> ParamSchema t
class GEnumParamSchema (f :: * -> *)
genumParamSchema :: GEnumParamSchema f => SchemaOptions -> proxy f -> ParamSchema t -> ParamSchema t
data Proxy3 a b c
Proxy3 :: Proxy3 a b c
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Base.String
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Types.Bool
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Integer.Type.Integer
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Types.Int
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Int.Int8
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Int.Int16
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Int.Int32
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Int.Int64
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Types.Word
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Word.Word8
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Word.Word16
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Word.Word32
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Word.Word64
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Types.Char
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Scientific.Scientific
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Types.Double
instance Data.Swagger.Internal.ParamSchema.ToParamSchema GHC.Types.Float
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Time.Calendar.Days.Day
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Time.LocalTime.LocalTime.LocalTime
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Time.LocalTime.LocalTime.ZonedTime
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Time.Clock.UTC.UTCTime
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Time.Clock.UTC.NominalDiffTime
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Text.Internal.Text
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Text.Internal.Lazy.Text
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Monoid.All
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Data.Monoid.Any
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.Monoid.Sum a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.Monoid.Product a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.Monoid.First a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.Monoid.Last a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.Monoid.Dual a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema [a]
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.Set.Base.Set a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema a => Data.Swagger.Internal.ParamSchema.ToParamSchema (Data.HashSet.HashSet a)
instance Data.Swagger.Internal.ParamSchema.ToParamSchema ()
instance Data.Swagger.Internal.ParamSchema.GToParamSchema f => Data.Swagger.Internal.ParamSchema.GToParamSchema (GHC.Generics.D1 d f)
instance GHC.Generics.Constructor c => Data.Swagger.Internal.ParamSchema.GToParamSchema (GHC.Generics.C1 c GHC.Generics.U1)
instance Data.Swagger.Internal.ParamSchema.GToParamSchema f => Data.Swagger.Internal.ParamSchema.GToParamSchema (GHC.Generics.C1 c (GHC.Generics.S1 s f))
instance Data.Swagger.Internal.ParamSchema.ToParamSchema c => Data.Swagger.Internal.ParamSchema.GToParamSchema (GHC.Generics.K1 i c)
instance (Data.Swagger.Internal.ParamSchema.GEnumParamSchema f, Data.Swagger.Internal.ParamSchema.GEnumParamSchema g) => Data.Swagger.Internal.ParamSchema.GToParamSchema (f GHC.Generics.:+: g)
instance (Data.Swagger.Internal.ParamSchema.GEnumParamSchema f, Data.Swagger.Internal.ParamSchema.GEnumParamSchema g) => Data.Swagger.Internal.ParamSchema.GEnumParamSchema (f GHC.Generics.:+: g)
instance GHC.Generics.Constructor c => Data.Swagger.Internal.ParamSchema.GEnumParamSchema (GHC.Generics.C1 c GHC.Generics.U1)


-- | Types and functions for working with Swagger parameter schema.
module Data.Swagger.ParamSchema

-- | Convert a type into a plain <tt><a>ParamSchema</a></tt>.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   
--   import Control.Lens
--   
--   data Direction = Up | Down
--   
--   instance ToParamSchema Direction where
--     toParamSchema = mempty
--        &amp; type_ .~ SwaggerString
--        &amp; enum_ .~ [ "Up", "Down" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToParamSchema</a></tt>
--   instance you can use a default generic implementation of
--   <tt><a>toParamSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>Generic</a></tt> clause to your
--   datatype and declare a <tt><a>ToParamSchema</a></tt> instance for your
--   datatype without giving definition for <tt><a>toParamSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Direction = Up | Down deriving Generic
--   
--   instance ToParamSchema Direction
--   </pre>
class ToParamSchema a where toParamSchema = genericToParamSchema defaultSchemaOptions

-- | Convert a type into a plain parameter schema.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toParamSchema (Proxy :: Proxy Integer)
--   "{\"type\":\"integer\"}"
--   </pre>
toParamSchema :: ToParamSchema a => proxy a -> ParamSchema t

-- | A configurable generic <tt><a>ParamSchema</a></tt> creator.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; data Color = Red | Blue deriving Generic
--   
--   &gt;&gt;&gt; encode $ genericToParamSchema defaultSchemaOptions (Proxy :: Proxy Color)
--   "{\"type\":\"string\",\"enum\":[\"Red\",\"Blue\"]}"
--   </pre>
genericToParamSchema :: (Generic a, GToParamSchema (Rep a)) => SchemaOptions -> proxy a -> ParamSchema t

-- | Default plain schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toParamSchemaBoundedIntegral (Proxy :: Proxy Int8)
--   "{\"maximum\":127,\"minimum\":-128,\"type\":\"integer\"}"
--   </pre>
toParamSchemaBoundedIntegral :: (Bounded a, Integral a) => proxy a -> ParamSchema t

-- | Options that specify how to encode your type to Swagger schema.
data SchemaOptions
SchemaOptions :: (String -> String) -> (String -> String) -> (String -> String) -> Bool -> Bool -> SchemaOptions

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: SchemaOptions -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: SchemaOptions -> String -> String

-- | Function applied to datatype name.
[datatypeNameModifier] :: SchemaOptions -> String -> String

-- | If <tt><a>True</a></tt> the constructors of a datatype, with all
--   nullary constructors, will be encoded to a string enumeration schema
--   with the constructor tags as possible values.
[allNullaryToStringTag] :: SchemaOptions -> Bool

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: SchemaOptions -> Bool

-- | Default encoding <tt><a>SchemaOptions</a></tt>.
--   
--   <pre>
--   <a>SchemaOptions</a>
--   { <a>fieldLabelModifier</a>     = id
--   , <a>constructorTagModifier</a> = id
--   , <a>datatypeNameModifier</a>   = id
--   , <a>allNullaryToStringTag</a>  = True
--   , <a>unwrapUnaryRecords</a>     = False
--   }
--   </pre>
defaultSchemaOptions :: SchemaOptions

module Data.Swagger.Internal.Schema
unnamed :: Schema -> NamedSchema
named :: Text -> Schema -> NamedSchema
plain :: Schema -> Declare (Definitions Schema) NamedSchema
unname :: NamedSchema -> NamedSchema
rename :: Maybe Text -> NamedSchema -> NamedSchema

-- | Convert a type into <tt><a>Schema</a></tt>.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   {-# LANGUAGE OverloadedLists #-}     -- allows to write <a>Map</a> and <a>HashMap</a> as lists
--   
--   import Control.Lens
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToSchema Coord where
--     declareNamedSchema = pure (Just "Coord", schema)
--      where
--        schema = mempty
--          &amp; type_ .~ SwaggerObject
--          &amp; properties .~
--              [ ("x", toSchemaRef (Proxy :: Proxy Double))
--              , ("y", toSchemaRef (Proxy :: Proxy Double))
--              ]
--          &amp; required .~ [ "x", "y" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToSchema</a></tt> instance you
--   can use a default generic implementation of
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>Generic</a></tt> clause to your
--   datatype and declare a <tt><a>ToSchema</a></tt> instance for your
--   datatype without giving definition for
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToSchema Coord
--   </pre>
class ToSchema a where declareNamedSchema = genericDeclareNamedSchema defaultSchemaOptions

-- | Convert a type into an optionally named schema together with all used
--   definitions. Note that the schema itself is included in definitions
--   only if it is recursive (and thus needs its definition in scope).
declareNamedSchema :: ToSchema a => proxy a -> Declare (Definitions Schema) NamedSchema

-- | Convert a type into a schema and declare all used schema definitions.
declareSchema :: ToSchema a => proxy a -> Declare (Definitions Schema) Schema

-- | Convert a type into an optionally named schema.
--   
--   <pre>
--   &gt;&gt;&gt; toNamedSchema (Proxy :: Proxy String) ^. name
--   Nothing
--   
--   &gt;&gt;&gt; encode (toNamedSchema (Proxy :: Proxy String) ^. schema)
--   "{\"type\":\"string\"}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toNamedSchema (Proxy :: Proxy Day) ^. name
--   Just "Day"
--   
--   &gt;&gt;&gt; encode (toNamedSchema (Proxy :: Proxy Day) ^. schema)
--   "{\"format\":\"date\",\"type\":\"string\"}"
--   </pre>
toNamedSchema :: ToSchema a => proxy a -> NamedSchema

-- | Get type's schema name according to its <tt><a>ToSchema</a></tt>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy UTCTime)
--   Just "UTCTime"
--   </pre>
schemaName :: ToSchema a => proxy a -> Maybe Text

-- | Convert a type into a schema.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchema (Proxy :: Proxy Int8)
--   "{\"maximum\":127,\"minimum\":-128,\"type\":\"integer\"}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchema (Proxy :: Proxy [Day])
--   "{\"items\":{\"$ref\":\"#/definitions/Day\"},\"type\":\"array\"}"
--   </pre>
toSchema :: ToSchema a => proxy a -> Schema

-- | Convert a type into a referenced schema if possible. Only named
--   schemas can be referenced, nameless schemas are inlined.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchemaRef (Proxy :: Proxy Integer)
--   "{\"type\":\"integer\"}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchemaRef (Proxy :: Proxy Day)
--   "{\"$ref\":\"#/definitions/Day\"}"
--   </pre>
toSchemaRef :: ToSchema a => proxy a -> Referenced Schema

-- | Convert a type into a referenced schema if possible and declare all
--   used schema definitions. Only named schemas can be referenced,
--   nameless schemas are inlined.
--   
--   Schema definitions are typically declared for every referenced schema.
--   If <tt><a>declareSchemaRef</a></tt> returns a reference, a
--   corresponding schema will be declared (regardless of whether it is
--   recusive or not).
declareSchemaRef :: ToSchema a => proxy a -> Declare (Definitions Schema) (Referenced Schema)

-- | Inline any referenced schema if its name satisfies given predicate.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions the
--   predicate is ignored and schema stays referenced.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemasWhen</a></tt> will produce
--   infinite schemas when inlining recursive schemas.
inlineSchemasWhen :: Data s => (Text -> Bool) -> (Definitions Schema) -> s -> s

-- | Inline any referenced schema if its name is in the given list.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions it
--   stays referenced even if it appears in the list of names.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineSchemas :: Data s => [Text] -> (Definitions Schema) -> s -> s

-- | Inline all schema references for which the definition can be found in
--   <tt><a>Definitions</a></tt>.
--   
--   <b>WARNING:</b> <tt><a>inlineAllSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineAllSchemas :: Data s => (Definitions Schema) -> s -> s

-- | Convert a type into a schema without references.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toInlinedSchema (Proxy :: Proxy [Day])
--   "{\"items\":{\"format\":\"date\",\"type\":\"string\"},\"type\":\"array\"}"
--   </pre>
--   
--   <b>WARNING:</b> <tt><a>toInlinedSchema</a></tt> will produce infinite
--   schema when inlining recursive schemas.
toInlinedSchema :: ToSchema a => proxy a -> Schema

-- | Inline all <i>non-recursive</i> schemas for which the definition can
--   be found in <tt><a>Definitions</a></tt>.
inlineNonRecursiveSchemas :: Data s => (Definitions Schema) -> s -> s
class GToSchema (f :: * -> *)
gdeclareNamedSchema :: GToSchema f => SchemaOptions -> proxy f -> Schema -> Declare (Definitions Schema) NamedSchema
timeSchema :: Text -> Schema

-- | Format <tt>"date"</tt> corresponds to <tt>yyyy-mm-dd</tt> format.

-- | <pre>
--   &gt;&gt;&gt; toSchema (Proxy :: Proxy LocalTime) ^. format
--   Just "yyyy-mm-ddThh:MM:ss"
--   </pre>

-- | Format <tt>"date"</tt> corresponds to
--   <tt>yyyy-mm-ddThh:MM:ss(Z|+hh:MM)</tt> format.

-- | <pre>
--   &gt;&gt;&gt; toSchema (Proxy :: Proxy UTCTime) ^. format
--   Just "yyyy-mm-ddThh:MM:ssZ"
--   </pre>

-- | NOTE: This schema does not account for the uniqueness of keys.

-- | Default schema for <tt><a>Bounded</a></tt>, <tt><a>Integral</a></tt>
--   types.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchemaBoundedIntegral (Proxy :: Proxy Int16)
--   "{\"maximum\":32767,\"minimum\":-32768,\"type\":\"integer\"}"
--   </pre>
toSchemaBoundedIntegral :: (Bounded a, Integral a) => proxy a -> Schema

-- | Default generic named schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
genericToNamedSchemaBoundedIntegral :: (Bounded a, Integral a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> proxy a -> NamedSchema

-- | A configurable generic <tt><a>Schema</a></tt> creator.
genericDeclareSchema :: (Generic a, GToSchema (Rep a)) => SchemaOptions -> proxy a -> Declare (Definitions Schema) Schema

-- | A configurable generic <tt><a>NamedSchema</a></tt> creator. This
--   function applied to <tt><a>defaultSchemaOptions</a></tt> is used as
--   the default for <tt><a>declareNamedSchema</a></tt> when the type is an
--   instance of <tt><a>Generic</a></tt>.
genericDeclareNamedSchema :: (Generic a, GToSchema (Rep a)) => SchemaOptions -> proxy a -> Declare (Definitions Schema) NamedSchema
gdatatypeSchemaName :: Datatype d => SchemaOptions -> proxy d -> Maybe Text

-- | Lift a plain <tt><a>ParamSchema</a></tt> into a model
--   <tt><a>NamedSchema</a></tt>.
paramSchemaToNamedSchema :: (ToParamSchema a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> proxy a -> NamedSchema

-- | Lift a plain <tt><a>ParamSchema</a></tt> into a model
--   <tt><a>Schema</a></tt>.
paramSchemaToSchema :: ToParamSchema a => proxy a -> Schema
nullarySchema :: Schema
gtoNamedSchema :: GToSchema f => SchemaOptions -> proxy f -> NamedSchema
gdeclareSchema :: GToSchema f => SchemaOptions -> proxy f -> Declare (Definitions Schema) Schema

-- | Single field constructor.
gdeclareSchemaRef :: GToSchema a => SchemaOptions -> proxy a -> Declare (Definitions Schema) (Referenced Schema)
appendItem :: Referenced Schema -> Maybe (SwaggerItems Schema) -> Maybe (SwaggerItems Schema)
withFieldSchema :: (Selector s, GToSchema f) => SchemaOptions -> proxy s f -> Bool -> Schema -> Declare (Definitions Schema) Schema

-- | Optional record fields.

-- | Record fields.
gdeclareNamedSumSchema :: GSumToSchema f => SchemaOptions -> proxy f -> Schema -> Declare (Definitions Schema) NamedSchema
type AllNullary = All
class GSumToSchema f
gsumToSchema :: GSumToSchema f => SchemaOptions -> proxy f -> Schema -> WriterT AllNullary (Declare (Definitions Schema)) Schema
gsumConToSchemaWith :: (GToSchema (C1 c f), Constructor c) => Referenced Schema -> SchemaOptions -> proxy (C1 c f) -> Schema -> Schema
gsumConToSchema :: (GToSchema (C1 c f), Constructor c) => SchemaOptions -> proxy (C1 c f) -> Schema -> Declare (Definitions Schema) Schema
data Proxy2 a b
Proxy2 :: Proxy2 a b
data Proxy3 a b c
Proxy3 :: Proxy3 a b c
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema [a]
instance Data.Swagger.Internal.Schema.ToSchema GHC.Base.String
instance Data.Swagger.Internal.Schema.ToSchema GHC.Types.Bool
instance Data.Swagger.Internal.Schema.ToSchema GHC.Integer.Type.Integer
instance Data.Swagger.Internal.Schema.ToSchema GHC.Types.Int
instance Data.Swagger.Internal.Schema.ToSchema GHC.Int.Int8
instance Data.Swagger.Internal.Schema.ToSchema GHC.Int.Int16
instance Data.Swagger.Internal.Schema.ToSchema GHC.Int.Int32
instance Data.Swagger.Internal.Schema.ToSchema GHC.Int.Int64
instance Data.Swagger.Internal.Schema.ToSchema GHC.Types.Word
instance Data.Swagger.Internal.Schema.ToSchema GHC.Word.Word8
instance Data.Swagger.Internal.Schema.ToSchema GHC.Word.Word16
instance Data.Swagger.Internal.Schema.ToSchema GHC.Word.Word32
instance Data.Swagger.Internal.Schema.ToSchema GHC.Word.Word64
instance Data.Swagger.Internal.Schema.ToSchema GHC.Types.Char
instance Data.Swagger.Internal.Schema.ToSchema Data.Scientific.Scientific
instance Data.Swagger.Internal.Schema.ToSchema GHC.Types.Double
instance Data.Swagger.Internal.Schema.ToSchema GHC.Types.Float
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (GHC.Base.Maybe a)
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b) => Data.Swagger.Internal.Schema.ToSchema (Data.Either.Either a b)
instance Data.Swagger.Internal.Schema.ToSchema ()
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b) => Data.Swagger.Internal.Schema.ToSchema (a, b)
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b, Data.Swagger.Internal.Schema.ToSchema c) => Data.Swagger.Internal.Schema.ToSchema (a, b, c)
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b, Data.Swagger.Internal.Schema.ToSchema c, Data.Swagger.Internal.Schema.ToSchema d) => Data.Swagger.Internal.Schema.ToSchema (a, b, c, d)
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b, Data.Swagger.Internal.Schema.ToSchema c, Data.Swagger.Internal.Schema.ToSchema d, Data.Swagger.Internal.Schema.ToSchema e) => Data.Swagger.Internal.Schema.ToSchema (a, b, c, d, e)
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b, Data.Swagger.Internal.Schema.ToSchema c, Data.Swagger.Internal.Schema.ToSchema d, Data.Swagger.Internal.Schema.ToSchema e, Data.Swagger.Internal.Schema.ToSchema f) => Data.Swagger.Internal.Schema.ToSchema (a, b, c, d, e, f)
instance (Data.Swagger.Internal.Schema.ToSchema a, Data.Swagger.Internal.Schema.ToSchema b, Data.Swagger.Internal.Schema.ToSchema c, Data.Swagger.Internal.Schema.ToSchema d, Data.Swagger.Internal.Schema.ToSchema e, Data.Swagger.Internal.Schema.ToSchema f, Data.Swagger.Internal.Schema.ToSchema g) => Data.Swagger.Internal.Schema.ToSchema (a, b, c, d, e, f, g)
instance Data.Swagger.Internal.Schema.ToSchema Data.Time.Calendar.Days.Day
instance Data.Swagger.Internal.Schema.ToSchema Data.Time.LocalTime.LocalTime.LocalTime
instance Data.Swagger.Internal.Schema.ToSchema Data.Time.LocalTime.LocalTime.ZonedTime
instance Data.Swagger.Internal.Schema.ToSchema Data.Time.Clock.UTC.NominalDiffTime
instance Data.Swagger.Internal.Schema.ToSchema Data.Time.Clock.UTC.UTCTime
instance Data.Swagger.Internal.Schema.ToSchema Data.Text.Internal.Text
instance Data.Swagger.Internal.Schema.ToSchema Data.Text.Internal.Lazy.Text
instance Data.Swagger.Internal.Schema.ToSchema Data.IntSet.Base.IntSet
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.IntMap.Base.IntMap a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Map.Base.Map GHC.Base.String a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Map.Base.Map Data.Text.Internal.Text a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Map.Base.Map Data.Text.Internal.Lazy.Text a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.HashMap.Base.HashMap GHC.Base.String a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.HashMap.Base.HashMap Data.Text.Internal.Text a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.HashMap.Base.HashMap Data.Text.Internal.Lazy.Text a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Set.Base.Set a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.HashSet.HashSet a)
instance Data.Swagger.Internal.Schema.ToSchema Data.Monoid.All
instance Data.Swagger.Internal.Schema.ToSchema Data.Monoid.Any
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Monoid.Sum a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Monoid.Product a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Monoid.First a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Monoid.Last a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Data.Monoid.Dual a)
instance (Data.Swagger.Internal.Schema.GToSchema f, Data.Swagger.Internal.Schema.GToSchema g) => Data.Swagger.Internal.Schema.GToSchema (f GHC.Generics.:*: g)
instance (GHC.Generics.Datatype d, Data.Swagger.Internal.Schema.GToSchema f) => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.D1 d f)
instance Data.Swagger.Internal.Schema.GToSchema f => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.C1 c f)
instance GHC.Generics.Constructor c => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.C1 c GHC.Generics.U1)
instance (GHC.Generics.Selector s, Data.Swagger.Internal.Schema.GToSchema f) => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.C1 c (GHC.Generics.S1 s f))
instance (GHC.Generics.Selector s, Data.Swagger.Internal.Schema.ToSchema c) => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.S1 s (GHC.Generics.K1 i (GHC.Base.Maybe c)))
instance (GHC.Generics.Selector s, Data.Swagger.Internal.Schema.GToSchema f) => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.S1 s f)
instance Data.Swagger.Internal.Schema.ToSchema c => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.K1 i (GHC.Base.Maybe c))
instance Data.Swagger.Internal.Schema.ToSchema c => Data.Swagger.Internal.Schema.GToSchema (GHC.Generics.K1 i c)
instance (Data.Swagger.Internal.Schema.GSumToSchema f, Data.Swagger.Internal.Schema.GSumToSchema g) => Data.Swagger.Internal.Schema.GToSchema (f GHC.Generics.:+: g)
instance (Data.Swagger.Internal.Schema.GSumToSchema f, Data.Swagger.Internal.Schema.GSumToSchema g) => Data.Swagger.Internal.Schema.GSumToSchema (f GHC.Generics.:+: g)
instance (GHC.Generics.Constructor c, Data.Swagger.Internal.Schema.GToSchema f) => Data.Swagger.Internal.Schema.GSumToSchema (GHC.Generics.C1 c f)
instance (GHC.Generics.Constructor c, GHC.Generics.Selector s, Data.Swagger.Internal.Schema.GToSchema f) => Data.Swagger.Internal.Schema.GSumToSchema (GHC.Generics.C1 c (GHC.Generics.S1 s f))
instance GHC.Generics.Constructor c => Data.Swagger.Internal.Schema.GSumToSchema (GHC.Generics.C1 c GHC.Generics.U1)


-- | Types and functions for working with Swagger schema.
module Data.Swagger.Schema

-- | Convert a type into <tt><a>Schema</a></tt>.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   {-# LANGUAGE OverloadedLists #-}     -- allows to write <a>Map</a> and <a>HashMap</a> as lists
--   
--   import Control.Lens
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToSchema Coord where
--     declareNamedSchema = pure (Just "Coord", schema)
--      where
--        schema = mempty
--          &amp; type_ .~ SwaggerObject
--          &amp; properties .~
--              [ ("x", toSchemaRef (Proxy :: Proxy Double))
--              , ("y", toSchemaRef (Proxy :: Proxy Double))
--              ]
--          &amp; required .~ [ "x", "y" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToSchema</a></tt> instance you
--   can use a default generic implementation of
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>Generic</a></tt> clause to your
--   datatype and declare a <tt><a>ToSchema</a></tt> instance for your
--   datatype without giving definition for
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToSchema Coord
--   </pre>
class ToSchema a where declareNamedSchema = genericDeclareNamedSchema defaultSchemaOptions

-- | Convert a type into an optionally named schema together with all used
--   definitions. Note that the schema itself is included in definitions
--   only if it is recursive (and thus needs its definition in scope).
declareNamedSchema :: ToSchema a => proxy a -> Declare (Definitions Schema) NamedSchema

-- | Convert a type into a schema and declare all used schema definitions.
declareSchema :: ToSchema a => proxy a -> Declare (Definitions Schema) Schema

-- | Convert a type into a referenced schema if possible and declare all
--   used schema definitions. Only named schemas can be referenced,
--   nameless schemas are inlined.
--   
--   Schema definitions are typically declared for every referenced schema.
--   If <tt><a>declareSchemaRef</a></tt> returns a reference, a
--   corresponding schema will be declared (regardless of whether it is
--   recusive or not).
declareSchemaRef :: ToSchema a => proxy a -> Declare (Definitions Schema) (Referenced Schema)

-- | Convert a type into a schema.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchema (Proxy :: Proxy Int8)
--   "{\"maximum\":127,\"minimum\":-128,\"type\":\"integer\"}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchema (Proxy :: Proxy [Day])
--   "{\"items\":{\"$ref\":\"#/definitions/Day\"},\"type\":\"array\"}"
--   </pre>
toSchema :: ToSchema a => proxy a -> Schema

-- | Convert a type into a referenced schema if possible. Only named
--   schemas can be referenced, nameless schemas are inlined.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchemaRef (Proxy :: Proxy Integer)
--   "{\"type\":\"integer\"}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchemaRef (Proxy :: Proxy Day)
--   "{\"$ref\":\"#/definitions/Day\"}"
--   </pre>
toSchemaRef :: ToSchema a => proxy a -> Referenced Schema

-- | Get type's schema name according to its <tt><a>ToSchema</a></tt>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy UTCTime)
--   Just "UTCTime"
--   </pre>
schemaName :: ToSchema a => proxy a -> Maybe Text

-- | Convert a type into a schema without references.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toInlinedSchema (Proxy :: Proxy [Day])
--   "{\"items\":{\"format\":\"date\",\"type\":\"string\"},\"type\":\"array\"}"
--   </pre>
--   
--   <b>WARNING:</b> <tt><a>toInlinedSchema</a></tt> will produce infinite
--   schema when inlining recursive schemas.
toInlinedSchema :: ToSchema a => proxy a -> Schema

-- | A configurable generic <tt><a>NamedSchema</a></tt> creator. This
--   function applied to <tt><a>defaultSchemaOptions</a></tt> is used as
--   the default for <tt><a>declareNamedSchema</a></tt> when the type is an
--   instance of <tt><a>Generic</a></tt>.
genericDeclareNamedSchema :: (Generic a, GToSchema (Rep a)) => SchemaOptions -> proxy a -> Declare (Definitions Schema) NamedSchema

-- | A configurable generic <tt><a>Schema</a></tt> creator.
genericDeclareSchema :: (Generic a, GToSchema (Rep a)) => SchemaOptions -> proxy a -> Declare (Definitions Schema) Schema

-- | Default generic named schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
genericToNamedSchemaBoundedIntegral :: (Bounded a, Integral a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> proxy a -> NamedSchema

-- | Default schema for <tt><a>Bounded</a></tt>, <tt><a>Integral</a></tt>
--   types.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ toSchemaBoundedIntegral (Proxy :: Proxy Int16)
--   "{\"maximum\":32767,\"minimum\":-32768,\"type\":\"integer\"}"
--   </pre>
toSchemaBoundedIntegral :: (Bounded a, Integral a) => proxy a -> Schema

-- | Lift a plain <tt><a>ParamSchema</a></tt> into a model
--   <tt><a>NamedSchema</a></tt>.
paramSchemaToNamedSchema :: (ToParamSchema a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> proxy a -> NamedSchema

-- | Lift a plain <tt><a>ParamSchema</a></tt> into a model
--   <tt><a>Schema</a></tt>.
paramSchemaToSchema :: ToParamSchema a => proxy a -> Schema

-- | Inline all <i>non-recursive</i> schemas for which the definition can
--   be found in <tt><a>Definitions</a></tt>.
inlineNonRecursiveSchemas :: Data s => (Definitions Schema) -> s -> s

-- | Inline all schema references for which the definition can be found in
--   <tt><a>Definitions</a></tt>.
--   
--   <b>WARNING:</b> <tt><a>inlineAllSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineAllSchemas :: Data s => (Definitions Schema) -> s -> s

-- | Inline any referenced schema if its name is in the given list.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions it
--   stays referenced even if it appears in the list of names.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineSchemas :: Data s => [Text] -> (Definitions Schema) -> s -> s

-- | Inline any referenced schema if its name satisfies given predicate.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions the
--   predicate is ignored and schema stays referenced.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemasWhen</a></tt> will produce
--   infinite schemas when inlining recursive schemas.
inlineSchemasWhen :: Data s => (Text -> Bool) -> (Definitions Schema) -> s -> s

-- | Options that specify how to encode your type to Swagger schema.
data SchemaOptions
SchemaOptions :: (String -> String) -> (String -> String) -> (String -> String) -> Bool -> Bool -> SchemaOptions

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: SchemaOptions -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: SchemaOptions -> String -> String

-- | Function applied to datatype name.
[datatypeNameModifier] :: SchemaOptions -> String -> String

-- | If <tt><a>True</a></tt> the constructors of a datatype, with all
--   nullary constructors, will be encoded to a string enumeration schema
--   with the constructor tags as possible values.
[allNullaryToStringTag] :: SchemaOptions -> Bool

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: SchemaOptions -> Bool

-- | Default encoding <tt><a>SchemaOptions</a></tt>.
--   
--   <pre>
--   <a>SchemaOptions</a>
--   { <a>fieldLabelModifier</a>     = id
--   , <a>constructorTagModifier</a> = id
--   , <a>datatypeNameModifier</a>   = id
--   , <a>allNullaryToStringTag</a>  = True
--   , <a>unwrapUnaryRecords</a>     = False
--   }
--   </pre>
defaultSchemaOptions :: SchemaOptions


-- | Helper traversals and functions for Swagger operations manipulations.
--   These might be useful when you already have Swagger specification
--   generated by something else.
module Data.Swagger.Operation

-- | All operations of a Swagger spec.
allOperations :: Traversal' Swagger Operation

-- | <tt><a>operationsOf</a> sub</tt> will traverse only those operations
--   that are present in <tt>sub</tt>. Note that <tt><a>Operation</a></tt>
--   is determined by both path and method.
--   
--   <pre>
--   &gt;&gt;&gt; let ok = (mempty :: Operation) &amp; at 200 ?~ "OK"
--   
--   &gt;&gt;&gt; let api = (mempty :: Swagger) &amp; paths .~ [("/user", mempty &amp; get ?~ ok &amp; post ?~ ok)]
--   
--   &gt;&gt;&gt; let sub = (mempty :: Swagger) &amp; paths .~ [("/user", mempty &amp; get ?~ mempty)]
--   
--   &gt;&gt;&gt; encode api
--   "{\"swagger\":\"2.0\",\"info\":{\"version\":\"\",\"title\":\"\"},\"paths\":{\"/user\":{\"post\":{\"responses\":{\"200\":{\"description\":\"OK\"}}},\"get\":{\"responses\":{\"200\":{\"description\":\"OK\"}}}}}}"
--   
--   &gt;&gt;&gt; encode $ api &amp; operationsOf sub . at 404 ?~ "Not found"
--   "{\"swagger\":\"2.0\",\"info\":{\"version\":\"\",\"title\":\"\"},\"paths\":{\"/user\":{\"post\":{\"responses\":{\"200\":{\"description\":\"OK\"}}},\"get\":{\"responses\":{\"404\":{\"description\":\"Not found\"},\"200\":{\"description\":\"OK\"}}}}}}"
--   </pre>
operationsOf :: Swagger -> Traversal' Swagger Operation

-- | Apply tags to all operations and update the global list of tags.
--   
--   <pre>
--   <a>applyTags</a> = <a>applyTagsFor</a> <a>allOperations</a>
--   </pre>
applyTags :: [Tag] -> Swagger -> Swagger

-- | Apply tags to a part of Swagger spec and update the global list of
--   tags.
applyTagsFor :: Traversal' Swagger Operation -> [Tag] -> Swagger -> Swagger

-- | Set response for all operations. This will also update global schema
--   definitions.
--   
--   If the response already exists it will be overwritten.
--   
--   <pre>
--   <a>setResponse</a> = <a>setResponseFor</a> <a>allOperations</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; let api = (mempty :: Swagger) &amp; paths .~ [("/user", mempty &amp; get ?~ mempty)]
--   
--   &gt;&gt;&gt; let res = declareResponse (Proxy :: Proxy Day)
--   
--   &gt;&gt;&gt; encode $ api &amp; setResponse 200 res
--   "{\"swagger\":\"2.0\",\"info\":{\"version\":\"\",\"title\":\"\"},\"definitions\":{\"Day\":{\"format\":\"date\",\"type\":\"string\"}},\"paths\":{\"/user\":{\"get\":{\"responses\":{\"200\":{\"schema\":{\"$ref\":\"#/definitions/Day\"},\"description\":\"\"}}}}}}"
--   </pre>
--   
--   See also <tt><a>setResponseWith</a></tt>.
setResponse :: HttpStatusCode -> Declare (Definitions Schema) Response -> Swagger -> Swagger

-- | Set or update response for all operations. This will also update
--   global schema definitions.
--   
--   If the response already exists, but it can't be dereferenced (invalid
--   <tt>$ref</tt>), then just the new response is used.
--   
--   <pre>
--   <a>setResponseWith</a> = <a>setResponseForWith</a> <a>allOperations</a>
--   </pre>
--   
--   See also <tt><a>setResponse</a></tt>.
setResponseWith :: (Response -> Response -> Response) -> HttpStatusCode -> Declare (Definitions Schema) Response -> Swagger -> Swagger

-- | Set response for specified operations. This will also update global
--   schema definitions.
--   
--   If the response already exists it will be overwritten.
--   
--   See also <tt><a>setResponseForWith</a></tt>.
setResponseFor :: Traversal' Swagger Operation -> HttpStatusCode -> Declare (Definitions Schema) Response -> Swagger -> Swagger

-- | Set or update response for specified operations. This will also update
--   global schema definitions.
--   
--   If the response already exists, but it can't be dereferenced (invalid
--   <tt>$ref</tt>), then just the new response is used.
--   
--   See also <tt><a>setResponseFor</a></tt>.
setResponseForWith :: Traversal' Swagger Operation -> (Response -> Response -> Response) -> HttpStatusCode -> Declare (Definitions Schema) Response -> Swagger -> Swagger

-- | Prepend path piece to all operations of the spec. Leading and trailing
--   slashes are trimmed/added automatically.
--   
--   <pre>
--   &gt;&gt;&gt; let api = (mempty :: Swagger) &amp; paths .~ [("/info", mempty)]
--   
--   &gt;&gt;&gt; encode $ prependPath "user/{user_id}" api ^. paths
--   "{\"/user/{user_id}/info\":{}}"
--   </pre>
prependPath :: FilePath -> Swagger -> Swagger

-- | Construct a response with <tt><a>Schema</a></tt> while declaring all
--   necessary schema definitions.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ runDeclare (declareResponse (Proxy :: Proxy Day)) mempty
--   "[{\"Day\":{\"format\":\"date\",\"type\":\"string\"}},{\"schema\":{\"$ref\":\"#/definitions/Day\"},\"description\":\"\"}]"
--   </pre>
declareResponse :: ToSchema a => proxy a -> Declare (Definitions Schema) Response


-- | Validate JSON values with Swagger Schema.
module Data.Swagger.Internal.Schema.Validation

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value. This can be used with
--   QuickCheck to ensure those instances are coherent:
--   
--   <pre>
--   validateToJSON (x :: Int) == []
--   </pre>
--   
--   <i>NOTE:</i> <tt><a>validateToJSON</a></tt> does not perform string
--   pattern validation. See
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
validateToJSON :: (ToJSON a, ToSchema a) => a -> [ValidationError]

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value and pattern checker. This
--   can be used with QuickCheck to ensure those instances are coherent.
--   
--   For validation without patterns see <tt><a>validateToJSON</a></tt>.
validateToJSONWithPatternChecker :: (ToJSON a, ToSchema a) => (Pattern -> Text -> Bool) -> a -> [ValidationError]

-- | Validation error message.
type ValidationError = String

-- | Validation result type.
data Result a

-- | Validation failed with a list of error messages.
Failed :: [ValidationError] -> Result a

-- | Validation passed.
Passed :: a -> Result a

-- | Validation configuration.
data Config
Config :: (Pattern -> Text -> Bool) -> Definitions Schema -> Config

-- | Pattern checker for <tt><a>_paramSchemaPattern</a></tt> validation.
[configPatternChecker] :: Config -> Pattern -> Text -> Bool

-- | Schema definitions in scope to resolve references.
[configDefinitions] :: Config -> Definitions Schema

-- | Default <tt><a>Config</a></tt>:
--   
--   <pre>
--   defaultConfig = <a>Config</a>
--     { <a>configPatternChecker</a> = \_pattern _str -&gt; True
--     , <a>configDefinitions</a>    = mempty
--     }
--   </pre>
defaultConfig :: Config

-- | Value validation.
newtype Validation s a
Validation :: (Config -> s -> Result a) -> Validation s a
[runValidation] :: Validation s a -> Config -> s -> Result a
withConfig :: (Config -> Validation s a) -> Validation s a
withSchema :: (s -> Validation s a) -> Validation s a

-- | Issue an error message.
invalid :: String -> Validation schema a

-- | Validation passed.
valid :: Validation schema ()

-- | Validate schema's property given a lens into that property and
--   property checker.
check :: Lens' s (Maybe a) -> (a -> Validation s ()) -> Validation s ()

-- | Validate same value with different schema.
sub :: t -> Validation t a -> Validation s a

-- | Validate same value with a part of the original schema.
sub_ :: Getting a s a -> Validation a r -> Validation s r

-- | Validate value against a schema given schema reference and validation
--   function.
withRef :: Reference -> (Schema -> Validation s a) -> Validation s a
validateWithSchemaRef :: Referenced Schema -> Value -> Validation s ()

-- | Validate JSON <tt><a>Value</a></tt> with Swagger
--   <tt><a>Schema</a></tt>.
validateWithSchema :: Value -> Validation Schema ()

-- | Validate JSON <tt><a>Value</a></tt> with Swagger
--   <tt><a>ParamSchema</a></tt>.
validateWithParamSchema :: Value -> Validation (ParamSchema t) ()
validateInteger :: Scientific -> Validation (ParamSchema t) ()
validateNumber :: Scientific -> Validation (ParamSchema t) ()
validateString :: Text -> Validation (ParamSchema t) ()
validateArray :: Vector Value -> Validation (ParamSchema t) ()
validateObject :: HashMap Text Value -> Validation Schema ()
validateEnum :: Value -> Validation (ParamSchema t) ()
validateSchemaType :: Value -> Validation Schema ()
validateParamSchemaType :: Value -> Validation (ParamSchema t) ()
instance GHC.Base.Functor (Data.Swagger.Internal.Schema.Validation.Validation s)
instance GHC.Base.Functor Data.Swagger.Internal.Schema.Validation.Result
instance GHC.Show.Show a => GHC.Show.Show (Data.Swagger.Internal.Schema.Validation.Result a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Swagger.Internal.Schema.Validation.Result a)
instance GHC.Base.Applicative Data.Swagger.Internal.Schema.Validation.Result
instance GHC.Base.Alternative Data.Swagger.Internal.Schema.Validation.Result
instance GHC.Base.Monad Data.Swagger.Internal.Schema.Validation.Result
instance GHC.Base.Applicative (Data.Swagger.Internal.Schema.Validation.Validation schema)
instance GHC.Base.Alternative (Data.Swagger.Internal.Schema.Validation.Validation schema)
instance Data.Profunctor.Unsafe.Profunctor Data.Swagger.Internal.Schema.Validation.Validation
instance Data.Profunctor.Choice.Choice Data.Swagger.Internal.Schema.Validation.Validation
instance GHC.Base.Monad (Data.Swagger.Internal.Schema.Validation.Validation s)


-- | Validate JSON values with Swagger Schema.
module Data.Swagger.Schema.Validation

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value. This can be used with
--   QuickCheck to ensure those instances are coherent:
--   
--   <pre>
--   validateToJSON (x :: Int) == []
--   </pre>
--   
--   <i>NOTE:</i> <tt><a>validateToJSON</a></tt> does not perform string
--   pattern validation. See
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
validateToJSON :: (ToJSON a, ToSchema a) => a -> [ValidationError]

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value and pattern checker. This
--   can be used with QuickCheck to ensure those instances are coherent.
--   
--   For validation without patterns see <tt><a>validateToJSON</a></tt>.
validateToJSONWithPatternChecker :: (ToJSON a, ToSchema a) => (Pattern -> Text -> Bool) -> a -> [ValidationError]

-- | Validation error message.
type ValidationError = String


-- | Swagger™ is a project used to describe and document RESTful APIs.
--   
--   The Swagger specification defines a set of files required to describe
--   such an API. These files can then be used by the Swagger-UI project to
--   display the API and Swagger-Codegen to generate clients in various
--   languages. Additional utilities can also take advantage of the
--   resulting files, such as testing tools.
module Data.Swagger

-- | This is the root document object for the API specification.
data Swagger
Swagger :: Info -> Maybe Host -> Maybe FilePath -> Maybe [Scheme] -> MimeList -> MimeList -> HashMap FilePath PathItem -> Definitions Schema -> Definitions Param -> Definitions Response -> Definitions SecurityScheme -> [SecurityRequirement] -> [Tag] -> Maybe ExternalDocs -> Swagger

-- | Provides metadata about the API. The metadata can be used by the
--   clients if needed.
[_swaggerInfo] :: Swagger -> Info

-- | The host (name or ip) serving the API. It MAY include a port. If the
--   host is not included, the host serving the documentation is to be used
--   (including the port).
[_swaggerHost] :: Swagger -> Maybe Host

-- | The base path on which the API is served, which is relative to the
--   host. If it is not included, the API is served directly under the
--   host. The value MUST start with a leading slash (/).
[_swaggerBasePath] :: Swagger -> Maybe FilePath

-- | The transfer protocol of the API. If the schemes is not included, the
--   default scheme to be used is the one used to access the Swagger
--   definition itself.
[_swaggerSchemes] :: Swagger -> Maybe [Scheme]

-- | A list of MIME types the APIs can consume. This is global to all APIs
--   but can be overridden on specific API calls.
[_swaggerConsumes] :: Swagger -> MimeList

-- | A list of MIME types the APIs can produce. This is global to all APIs
--   but can be overridden on specific API calls.
[_swaggerProduces] :: Swagger -> MimeList

-- | The available paths and operations for the API. Holds the relative
--   paths to the individual endpoints. The path is appended to the
--   <tt><tt>basePath</tt></tt> in order to construct the full URL.
[_swaggerPaths] :: Swagger -> HashMap FilePath PathItem

-- | An object to hold data types produced and consumed by operations.
[_swaggerDefinitions] :: Swagger -> Definitions Schema

-- | An object to hold parameters that can be used across operations. This
--   property does not define global parameters for all operations.
[_swaggerParameters] :: Swagger -> Definitions Param

-- | An object to hold responses that can be used across operations. This
--   property does not define global responses for all operations.
[_swaggerResponses] :: Swagger -> Definitions Response

-- | Security scheme definitions that can be used across the specification.
[_swaggerSecurityDefinitions] :: Swagger -> Definitions SecurityScheme

-- | A declaration of which security schemes are applied for the API as a
--   whole. The list of values describes alternative security schemes that
--   can be used (that is, there is a logical OR between the security
--   requirements). Individual operations can override this definition.
[_swaggerSecurity] :: Swagger -> [SecurityRequirement]

-- | A list of tags used by the specification with additional metadata. The
--   order of the tags can be used to reflect on their order by the parsing
--   tools. Not all tags that are used by the Operation Object must be
--   declared. The tags that are not declared may be organized randomly or
--   based on the tools' logic. Each tag name in the list MUST be unique.
[_swaggerTags] :: Swagger -> [Tag]

-- | Additional external documentation.
[_swaggerExternalDocs] :: Swagger -> Maybe ExternalDocs

-- | The host (name or ip) serving the API. It MAY include a port.
data Host
Host :: HostName -> Maybe PortNumber -> Host

-- | Host name.
[_hostName] :: Host -> HostName

-- | Optional port.
[_hostPort] :: Host -> Maybe PortNumber

-- | The transfer protocol of the API.
data Scheme
Http :: Scheme
Https :: Scheme
Ws :: Scheme
Wss :: Scheme

-- | The object provides metadata about the API. The metadata can be used
--   by the clients if needed, and can be presented in the Swagger-UI for
--   convenience.
data Info
Info :: Text -> Maybe Text -> Maybe Text -> Maybe Contact -> Maybe License -> Text -> Info

-- | The title of the application.
[_infoTitle] :: Info -> Text

-- | A short description of the application. GFM syntax can be used for
--   rich text representation.
[_infoDescription] :: Info -> Maybe Text

-- | The Terms of Service for the API.
[_infoTermsOfService] :: Info -> Maybe Text

-- | The contact information for the exposed API.
[_infoContact] :: Info -> Maybe Contact

-- | The license information for the exposed API.
[_infoLicense] :: Info -> Maybe License

-- | Provides the version of the application API (not to be confused with
--   the specification version).
[_infoVersion] :: Info -> Text

-- | Contact information for the exposed API.
data Contact
Contact :: Maybe Text -> Maybe URL -> Maybe Text -> Contact

-- | The identifying name of the contact person/organization.
[_contactName] :: Contact -> Maybe Text

-- | The URL pointing to the contact information.
[_contactUrl] :: Contact -> Maybe URL

-- | The email address of the contact person/organization.
[_contactEmail] :: Contact -> Maybe Text

-- | License information for the exposed API.
data License
License :: Text -> Maybe URL -> License

-- | The license name used for the API.
[_licenseName] :: License -> Text

-- | A URL to the license used for the API.
[_licenseUrl] :: License -> Maybe URL

-- | Describes the operations available on a single path. A
--   <tt><a>PathItem</a></tt> may be empty, due to ACL constraints. The
--   path itself is still exposed to the documentation viewer but they will
--   not know which operations and parameters are available.
data PathItem
PathItem :: Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> [Referenced Param] -> PathItem

-- | A definition of a GET operation on this path.
[_pathItemGet] :: PathItem -> Maybe Operation

-- | A definition of a PUT operation on this path.
[_pathItemPut] :: PathItem -> Maybe Operation

-- | A definition of a POST operation on this path.
[_pathItemPost] :: PathItem -> Maybe Operation

-- | A definition of a DELETE operation on this path.
[_pathItemDelete] :: PathItem -> Maybe Operation

-- | A definition of a OPTIONS operation on this path.
[_pathItemOptions] :: PathItem -> Maybe Operation

-- | A definition of a HEAD operation on this path.
[_pathItemHead] :: PathItem -> Maybe Operation

-- | A definition of a PATCH operation on this path.
[_pathItemPatch] :: PathItem -> Maybe Operation

-- | A list of parameters that are applicable for all the operations
--   described under this path. These parameters can be overridden at the
--   operation level, but cannot be removed there. The list MUST NOT
--   include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_pathItemParameters] :: PathItem -> [Referenced Param]

-- | Describes a single API operation on a path.
data Operation
Operation :: [TagName] -> Maybe Text -> Maybe Text -> Maybe ExternalDocs -> Maybe Text -> Maybe MimeList -> Maybe MimeList -> [Referenced Param] -> Responses -> Maybe [Scheme] -> Maybe Bool -> [SecurityRequirement] -> Operation

-- | A list of tags for API documentation control. Tags can be used for
--   logical grouping of operations by resources or any other qualifier.
[_operationTags] :: Operation -> [TagName]

-- | A short summary of what the operation does. For maximum readability in
--   the swagger-ui, this field SHOULD be less than 120 characters.
[_operationSummary] :: Operation -> Maybe Text

-- | A verbose explanation of the operation behavior. GFM syntax can be
--   used for rich text representation.
[_operationDescription] :: Operation -> Maybe Text

-- | Additional external documentation for this operation.
[_operationExternalDocs] :: Operation -> Maybe ExternalDocs

-- | Unique string used to identify the operation. The id MUST be unique
--   among all operations described in the API. Tools and libraries MAY use
--   the it to uniquely identify an operation, therefore, it is recommended
--   to follow common programming naming conventions.
[_operationOperationId] :: Operation -> Maybe Text

-- | A list of MIME types the operation can consume. This overrides the
--   <tt><tt>consumes</tt></tt>. <tt>Just []</tt> MAY be used to clear the
--   global definition.
[_operationConsumes] :: Operation -> Maybe MimeList

-- | A list of MIME types the operation can produce. This overrides the
--   <tt><tt>produces</tt></tt>. <tt>Just []</tt> MAY be used to clear the
--   global definition.
[_operationProduces] :: Operation -> Maybe MimeList

-- | A list of parameters that are applicable for this operation. If a
--   parameter is already defined at the <tt><a>PathItem</a></tt>, the new
--   definition will override it, but can never remove it. The list MUST
--   NOT include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_operationParameters] :: Operation -> [Referenced Param]

-- | The list of possible responses as they are returned from executing
--   this operation.
[_operationResponses] :: Operation -> Responses

-- | The transfer protocol for the operation. The value overrides
--   <tt><tt>schemes</tt></tt>.
[_operationSchemes] :: Operation -> Maybe [Scheme]

-- | Declares this operation to be deprecated. Usage of the declared
--   operation should be refrained. Default value is <tt>False</tt>.
[_operationDeprecated] :: Operation -> Maybe Bool

-- | A declaration of which security schemes are applied for this
--   operation. The list of values describes alternative security schemes
--   that can be used (that is, there is a logical OR between the security
--   requirements). This definition overrides any declared top-level
--   security. To remove a top-level security declaration, <tt>Just []</tt>
--   can be used.
[_operationSecurity] :: Operation -> [SecurityRequirement]

-- | Allows adding meta data to a single tag that is used by
--   <tt>Operation</tt>. It is not mandatory to have a <tt>Tag</tt> per tag
--   used there.
data Tag
Tag :: TagName -> Maybe Text -> Maybe ExternalDocs -> Tag

-- | The name of the tag.
[_tagName] :: Tag -> TagName

-- | A short description for the tag. GFM syntax can be used for rich text
--   representation.
[_tagDescription] :: Tag -> Maybe Text

-- | Additional external documentation for this tag.
[_tagExternalDocs] :: Tag -> Maybe ExternalDocs

-- | Tag name.
type TagName = Text
data SwaggerType t
SwaggerString :: SwaggerType t
SwaggerNumber :: SwaggerType t
SwaggerInteger :: SwaggerType t
SwaggerBoolean :: SwaggerType t
SwaggerArray :: SwaggerType t
SwaggerFile :: SwaggerType ParamOtherSchema
SwaggerNull :: SwaggerType Schema
SwaggerObject :: SwaggerType Schema
type Format = Text

-- | A list of definitions that can be used in references.
type Definitions = HashMap Text

-- | Determines the format of the array.
data CollectionFormat t
CollectionCSV :: CollectionFormat t
CollectionSSV :: CollectionFormat t
CollectionTSV :: CollectionFormat t
CollectionPipes :: CollectionFormat t
CollectionMulti :: CollectionFormat ParamOtherSchema

-- | Describes a single operation parameter. A unique parameter is defined
--   by a combination of a name and location.
data Param
Param :: Text -> Maybe Text -> Maybe Bool -> ParamAnySchema -> Param

-- | The name of the parameter. Parameter names are case sensitive.
[_paramName] :: Param -> Text

-- | A brief description of the parameter. This could contain examples of
--   use. GFM syntax can be used for rich text representation.
[_paramDescription] :: Param -> Maybe Text

-- | Determines whether this parameter is mandatory. If the parameter is in
--   "path", this property is required and its value MUST be true.
--   Otherwise, the property MAY be included and its default value is
--   <tt>False</tt>.
[_paramRequired] :: Param -> Maybe Bool

-- | Parameter schema.
[_paramSchema] :: Param -> ParamAnySchema
data ParamAnySchema
ParamBody :: (Referenced Schema) -> ParamAnySchema
ParamOther :: ParamOtherSchema -> ParamAnySchema
data ParamOtherSchema
ParamOtherSchema :: ParamLocation -> Maybe Bool -> ParamSchema ParamOtherSchema -> ParamOtherSchema

-- | The location of the parameter.
[_paramOtherSchemaIn] :: ParamOtherSchema -> ParamLocation

-- | Sets the ability to pass empty-valued parameters. This is valid only
--   for either <tt><a>ParamQuery</a></tt> or <tt><a>ParamFormData</a></tt>
--   and allows you to send a parameter with a name only or an empty value.
--   Default value is <tt>False</tt>.
[_paramOtherSchemaAllowEmptyValue] :: ParamOtherSchema -> Maybe Bool
[_paramOtherSchemaParamSchema] :: ParamOtherSchema -> ParamSchema ParamOtherSchema
data ParamLocation

-- | Parameters that are appended to the URL. For example, in
--   <tt>/items?id=###</tt>, the query parameter is <tt>id</tt>.
ParamQuery :: ParamLocation

-- | Custom headers that are expected as part of the request.
ParamHeader :: ParamLocation

-- | Used together with Path Templating, where the parameter value is
--   actually part of the operation's URL. This does not include the host
--   or base path of the API. For example, in
--   <tt><i>items</i>{itemId}</tt>, the path parameter is <tt>itemId</tt>.
ParamPath :: ParamLocation

-- | Used to describe the payload of an HTTP request when either
--   <tt>application/x-www-form-urlencoded</tt> or
--   <tt>multipart/form-data</tt> are used as the content type of the
--   request (in Swagger's definition, the <tt>consumes</tt> property of an
--   operation). This is the only parameter type that can be used to send
--   files, thus supporting the <tt><tt>ParamFile</tt></tt> type. Since
--   form parameters are sent in the payload, they cannot be declared
--   together with a body parameter for the same operation. Form parameters
--   have a different format based on the content-type used (for further
--   details, consult
--   <a>http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4</a>).
ParamFormData :: ParamLocation
type ParamName = Text
data Header
Header :: Maybe Text -> ParamSchema Header -> Header

-- | A short description of the header.
[_headerDescription] :: Header -> Maybe Text
[_headerParamSchema] :: Header -> ParamSchema Header
type HeaderName = Text
data Example
Example :: Map MediaType Value -> Example
[getExample] :: Example -> Map MediaType Value
data ParamSchema t
ParamSchema :: Maybe Value -> SwaggerType t -> Maybe Format -> Maybe (SwaggerItems t) -> Maybe Scientific -> Maybe Bool -> Maybe Scientific -> Maybe Bool -> Maybe Integer -> Maybe Integer -> Maybe Pattern -> Maybe Integer -> Maybe Integer -> Maybe Bool -> Maybe [Value] -> Maybe Scientific -> ParamSchema t

-- | Declares the value of the parameter that the server will use if none
--   is provided, for example a <tt>"count"</tt> to control the number of
--   results per page might default to <tt>100</tt> if not supplied by the
--   client in the request. (Note: "default" has no meaning for required
--   parameters.) Unlike JSON Schema this value MUST conform to the defined
--   type for this parameter.
[_paramSchemaDefault] :: ParamSchema t -> Maybe Value
[_paramSchemaType] :: ParamSchema t -> SwaggerType t
[_paramSchemaFormat] :: ParamSchema t -> Maybe Format
[_paramSchemaItems] :: ParamSchema t -> Maybe (SwaggerItems t)
[_paramSchemaMaximum] :: ParamSchema t -> Maybe Scientific
[_paramSchemaExclusiveMaximum] :: ParamSchema t -> Maybe Bool
[_paramSchemaMinimum] :: ParamSchema t -> Maybe Scientific
[_paramSchemaExclusiveMinimum] :: ParamSchema t -> Maybe Bool
[_paramSchemaMaxLength] :: ParamSchema t -> Maybe Integer
[_paramSchemaMinLength] :: ParamSchema t -> Maybe Integer
[_paramSchemaPattern] :: ParamSchema t -> Maybe Pattern
[_paramSchemaMaxItems] :: ParamSchema t -> Maybe Integer
[_paramSchemaMinItems] :: ParamSchema t -> Maybe Integer
[_paramSchemaUniqueItems] :: ParamSchema t -> Maybe Bool
[_paramSchemaEnum] :: ParamSchema t -> Maybe [Value]
[_paramSchemaMultipleOf] :: ParamSchema t -> Maybe Scientific
data Schema
Schema :: Maybe Text -> Maybe Text -> [ParamName] -> Maybe [Schema] -> HashMap Text (Referenced Schema) -> Maybe Schema -> Maybe Text -> Maybe Bool -> Maybe Xml -> Maybe ExternalDocs -> Maybe Value -> Maybe Integer -> Maybe Integer -> ParamSchema Schema -> Schema
[_schemaTitle] :: Schema -> Maybe Text
[_schemaDescription] :: Schema -> Maybe Text
[_schemaRequired] :: Schema -> [ParamName]
[_schemaAllOf] :: Schema -> Maybe [Schema]
[_schemaProperties] :: Schema -> HashMap Text (Referenced Schema)
[_schemaAdditionalProperties] :: Schema -> Maybe Schema
[_schemaDiscriminator] :: Schema -> Maybe Text
[_schemaReadOnly] :: Schema -> Maybe Bool
[_schemaXml] :: Schema -> Maybe Xml
[_schemaExternalDocs] :: Schema -> Maybe ExternalDocs
[_schemaExample] :: Schema -> Maybe Value
[_schemaMaxProperties] :: Schema -> Maybe Integer
[_schemaMinProperties] :: Schema -> Maybe Integer
[_schemaParamSchema] :: Schema -> ParamSchema Schema

-- | A <tt><a>Schema</a></tt> with an optional name. This name can be used
--   in references.
data NamedSchema
NamedSchema :: Maybe Text -> Schema -> NamedSchema
[_namedSchemaName] :: NamedSchema -> Maybe Text
[_namedSchemaSchema] :: NamedSchema -> Schema

-- | Items for <tt><a>SwaggerArray</a></tt> schemas.
--   
--   <tt><a>SwaggerItemsPrimitive</a></tt> should be used only for query
--   params, headers and path pieces. The <tt><a>CollectionFormat</a>
--   t</tt> parameter specifies how elements of an array should be
--   displayed. Note that <tt>fmt</tt> in <tt><a>SwaggerItemsPrimitive</a>
--   fmt schema</tt> specifies format for elements of type <tt>schema</tt>.
--   This is different from the original Swagger's <a>Items Object</a>.
--   
--   <tt><a>SwaggerItemsObject</a></tt> should be used to specify
--   homogenous array <tt><a>Schema</a></tt>s.
--   
--   <tt><a>SwaggerItemsArray</a></tt> should be used to specify tuple
--   <tt><a>Schema</a></tt>s.
data SwaggerItems t
SwaggerItemsPrimitive :: Maybe (CollectionFormat t) -> ParamSchema t -> SwaggerItems t
SwaggerItemsObject :: Referenced Schema -> SwaggerItems Schema
SwaggerItemsArray :: [Referenced Schema] -> SwaggerItems Schema
data Xml
Xml :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> Xml

-- | Replaces the name of the element/attribute used for the described
--   schema property. When defined within the <tt><a>SwaggerItems</a></tt>
--   (items), it will affect the name of the individual XML elements within
--   the list. When defined alongside type being array (outside the items),
--   it will affect the wrapping element and only if wrapped is true. If
--   wrapped is false, it will be ignored.
[_xmlName] :: Xml -> Maybe Text

-- | The URL of the namespace definition. Value SHOULD be in the form of a
--   URL.
[_xmlNamespace] :: Xml -> Maybe Text

-- | The prefix to be used for the name.
[_xmlPrefix] :: Xml -> Maybe Text

-- | Declares whether the property definition translates to an attribute
--   instead of an element. Default value is <tt>False</tt>.
[_xmlAttribute] :: Xml -> Maybe Bool

-- | MAY be used only for an array definition. Signifies whether the array
--   is wrapped (for example,
--   <tt>&lt;books&gt;&lt;book<i>&gt;&lt;book</i>&gt;&lt;/books&gt;</tt>)
--   or unwrapped (<tt>&lt;book<i>&gt;&lt;book</i>&gt;</tt>). Default value
--   is <tt>False</tt>. The definition takes effect only when defined
--   alongside type being array (outside the items).
[_xmlWrapped] :: Xml -> Maybe Bool

-- | A container for the expected responses of an operation. The container
--   maps a HTTP response code to the expected response. It is not expected
--   from the documentation to necessarily cover all possible HTTP response
--   codes, since they may not be known in advance. However, it is expected
--   from the documentation to cover a successful operation response and
--   any known errors.
data Responses
Responses :: Maybe (Referenced Response) -> HashMap HttpStatusCode (Referenced Response) -> Responses

-- | The documentation of responses other than the ones declared for
--   specific HTTP response codes. It can be used to cover undeclared
--   responses.
[_responsesDefault] :: Responses -> Maybe (Referenced Response)

-- | Any HTTP status code can be used as the property name (one property
--   per HTTP status code). Describes the expected response for those HTTP
--   status codes.
[_responsesResponses] :: Responses -> HashMap HttpStatusCode (Referenced Response)

-- | Describes a single response from an API Operation.
data Response
Response :: Text -> Maybe (Referenced Schema) -> HashMap HeaderName Header -> Maybe Example -> Response

-- | A short description of the response. GFM syntax can be used for rich
--   text representation.
[_responseDescription] :: Response -> Text

-- | A definition of the response structure. It can be a primitive, an
--   array or an object. If this field does not exist, it means no content
--   is returned as part of the response. As an extension to the Schema
--   Object, its root type value may also be "file". This SHOULD be
--   accompanied by a relevant produces mime-type.
[_responseSchema] :: Response -> Maybe (Referenced Schema)

-- | A list of headers that are sent with the response.
[_responseHeaders] :: Response -> HashMap HeaderName Header

-- | An example of the response message.
[_responseExamples] :: Response -> Maybe Example
type HttpStatusCode = Int
data SecurityScheme
SecurityScheme :: SecuritySchemeType -> Maybe Text -> SecurityScheme

-- | The type of the security scheme.
[_securitySchemeType] :: SecurityScheme -> SecuritySchemeType

-- | A short description for security scheme.
[_securitySchemeDescription] :: SecurityScheme -> Maybe Text
data SecuritySchemeType
SecuritySchemeBasic :: SecuritySchemeType
SecuritySchemeApiKey :: ApiKeyParams -> SecuritySchemeType
SecuritySchemeOAuth2 :: OAuth2Params -> SecuritySchemeType

-- | Lists the required security schemes to execute this operation. The
--   object can have multiple security schemes declared in it which are all
--   required (that is, there is a logical AND between the schemes).
newtype SecurityRequirement
SecurityRequirement :: HashMap Text [Text] -> SecurityRequirement
[getSecurityRequirement] :: SecurityRequirement -> HashMap Text [Text]
data ApiKeyParams
ApiKeyParams :: Text -> ApiKeyLocation -> ApiKeyParams

-- | The name of the header or query parameter to be used.
[_apiKeyName] :: ApiKeyParams -> Text

-- | The location of the API key.
[_apiKeyIn] :: ApiKeyParams -> ApiKeyLocation

-- | The location of the API key.
data ApiKeyLocation
ApiKeyQuery :: ApiKeyLocation
ApiKeyHeader :: ApiKeyLocation
data OAuth2Params
OAuth2Params :: OAuth2Flow -> HashMap Text Text -> OAuth2Params

-- | The flow used by the OAuth2 security scheme.
[_oauth2Flow] :: OAuth2Params -> OAuth2Flow

-- | The available scopes for the OAuth2 security scheme.
[_oauth2Scopes] :: OAuth2Params -> HashMap Text Text
data OAuth2Flow
OAuth2Implicit :: AuthorizationURL -> OAuth2Flow
OAuth2Password :: TokenURL -> OAuth2Flow
OAuth2Application :: TokenURL -> OAuth2Flow
OAuth2AccessCode :: AuthorizationURL -> TokenURL -> OAuth2Flow

-- | The authorization URL to be used for OAuth2 flow. This SHOULD be in
--   the form of a URL.
type AuthorizationURL = Text

-- | The token URL to be used for OAuth2 flow. This SHOULD be in the form
--   of a URL.
type TokenURL = Text

-- | Allows referencing an external resource for extended documentation.
data ExternalDocs
ExternalDocs :: Maybe Text -> URL -> ExternalDocs

-- | A short description of the target documentation. GFM syntax can be
--   used for rich text representation.
[_externalDocsDescription] :: ExternalDocs -> Maybe Text

-- | The URL for the target documentation.
[_externalDocsUrl] :: ExternalDocs -> URL

-- | A simple object to allow referencing other definitions in the
--   specification. It can be used to reference parameters and responses
--   that are defined at the top level for reuse.
newtype Reference
Reference :: Text -> Reference
[getReference] :: Reference -> Text
data Referenced a
Ref :: Reference -> Referenced a
Inline :: a -> Referenced a
newtype MimeList
MimeList :: [MediaType] -> MimeList
[getMimeList] :: MimeList -> [MediaType]
newtype URL
URL :: Text -> URL
[getUrl] :: URL -> Text
